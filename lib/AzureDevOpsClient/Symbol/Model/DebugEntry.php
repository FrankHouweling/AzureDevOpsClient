<?php
/**
 * DebugEntry
 *
 * PHP version 5
 *
 * @category Class
 * @package  FrankHouweling\AzureDevOpsClient\Symbol
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Symbol
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0-preview
 * Contact: nugetvss@microsoft.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.11-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace FrankHouweling\AzureDevOpsClient\Symbol\Model;

use \ArrayAccess;
use \FrankHouweling\AzureDevOpsClient\Symbol\ObjectSerializer;

/**
 * DebugEntry Class Doc Comment
 *
 * @category Class
 * @description A dual-purpose data object, the debug entry is used by the client to publish the symbol file (with file&#39;s blob identifier, which can be calculated from VSTS hashing algorithm) or query the file (with a client key). Since the symbol server tries to return a matched symbol file with the richest information level, it may not always point to the same symbol file for different queries with same client key.
 * @package  FrankHouweling\AzureDevOpsClient\Symbol
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DebugEntry implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'DebugEntry';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'createdBy' => 'string',
        'createdDate' => '\DateTime',
        'id' => 'string',
        'storageETag' => 'string',
        'url' => 'string',
        'blobDetails' => '\FrankHouweling\AzureDevOpsClient\Symbol\Model\JsonBlobIdentifierWithBlocks',
        'blobIdentifier' => '\FrankHouweling\AzureDevOpsClient\Symbol\Model\JsonBlobIdentifier',
        'blobUri' => 'string',
        'clientKey' => 'string',
        'informationLevel' => 'string',
        'requestId' => 'string',
        'status' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'createdBy' => 'uuid',
        'createdDate' => 'date-time',
        'id' => null,
        'storageETag' => null,
        'url' => null,
        'blobDetails' => null,
        'blobIdentifier' => null,
        'blobUri' => null,
        'clientKey' => null,
        'informationLevel' => null,
        'requestId' => null,
        'status' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'createdBy' => 'createdBy',
        'createdDate' => 'createdDate',
        'id' => 'id',
        'storageETag' => 'storageETag',
        'url' => 'url',
        'blobDetails' => 'blobDetails',
        'blobIdentifier' => 'blobIdentifier',
        'blobUri' => 'blobUri',
        'clientKey' => 'clientKey',
        'informationLevel' => 'informationLevel',
        'requestId' => 'requestId',
        'status' => 'status'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'createdBy' => 'setCreatedBy',
        'createdDate' => 'setCreatedDate',
        'id' => 'setId',
        'storageETag' => 'setStorageETag',
        'url' => 'setUrl',
        'blobDetails' => 'setBlobDetails',
        'blobIdentifier' => 'setBlobIdentifier',
        'blobUri' => 'setBlobUri',
        'clientKey' => 'setClientKey',
        'informationLevel' => 'setInformationLevel',
        'requestId' => 'setRequestId',
        'status' => 'setStatus'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'createdBy' => 'getCreatedBy',
        'createdDate' => 'getCreatedDate',
        'id' => 'getId',
        'storageETag' => 'getStorageETag',
        'url' => 'getUrl',
        'blobDetails' => 'getBlobDetails',
        'blobIdentifier' => 'getBlobIdentifier',
        'blobUri' => 'getBlobUri',
        'clientKey' => 'getClientKey',
        'informationLevel' => 'getInformationLevel',
        'requestId' => 'getRequestId',
        'status' => 'getStatus'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const INFORMATION_LEVEL_NONE = 'none';
    const INFORMATION_LEVEL_BINARY = 'binary';
    const INFORMATION_LEVEL_PUBLICS = 'publics';
    const INFORMATION_LEVEL_TRACE_FORMAT_PRESENT = 'traceFormatPresent';
    const INFORMATION_LEVEL_TYPE_INFO = 'typeInfo';
    const INFORMATION_LEVEL_LINE_NUMBERS = 'lineNumbers';
    const INFORMATION_LEVEL_GLOBAL_SYMBOLS = 'globalSymbols';
    const INFORMATION_LEVEL__PRIVATE = 'private';
    const INFORMATION_LEVEL_SOURCE_INDEXED = 'sourceIndexed';
    const STATUS_NONE = 'none';
    const STATUS_CREATED = 'created';
    const STATUS_BLOB_MISSING = 'blobMissing';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getInformationLevelAllowableValues()
    {
        return [
            self::INFORMATION_LEVEL_NONE,
            self::INFORMATION_LEVEL_BINARY,
            self::INFORMATION_LEVEL_PUBLICS,
            self::INFORMATION_LEVEL_TRACE_FORMAT_PRESENT,
            self::INFORMATION_LEVEL_TYPE_INFO,
            self::INFORMATION_LEVEL_LINE_NUMBERS,
            self::INFORMATION_LEVEL_GLOBAL_SYMBOLS,
            self::INFORMATION_LEVEL__PRIVATE,
            self::INFORMATION_LEVEL_SOURCE_INDEXED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_NONE,
            self::STATUS_CREATED,
            self::STATUS_BLOB_MISSING,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['createdBy'] = isset($data['createdBy']) ? $data['createdBy'] : null;
        $this->container['createdDate'] = isset($data['createdDate']) ? $data['createdDate'] : null;
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['storageETag'] = isset($data['storageETag']) ? $data['storageETag'] : null;
        $this->container['url'] = isset($data['url']) ? $data['url'] : null;
        $this->container['blobDetails'] = isset($data['blobDetails']) ? $data['blobDetails'] : null;
        $this->container['blobIdentifier'] = isset($data['blobIdentifier']) ? $data['blobIdentifier'] : null;
        $this->container['blobUri'] = isset($data['blobUri']) ? $data['blobUri'] : null;
        $this->container['clientKey'] = isset($data['clientKey']) ? $data['clientKey'] : null;
        $this->container['informationLevel'] = isset($data['informationLevel']) ? $data['informationLevel'] : null;
        $this->container['requestId'] = isset($data['requestId']) ? $data['requestId'] : null;
        $this->container['status'] = isset($data['status']) ? $data['status'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getInformationLevelAllowableValues();
        if (!is_null($this->container['informationLevel']) && !in_array($this->container['informationLevel'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'informationLevel', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'status', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets createdBy
     *
     * @return string
     */
    public function getCreatedBy()
    {
        return $this->container['createdBy'];
    }

    /**
     * Sets createdBy
     *
     * @param string $createdBy The ID of user who created this item. Optional.
     *
     * @return $this
     */
    public function setCreatedBy($createdBy)
    {
        $this->container['createdBy'] = $createdBy;

        return $this;
    }

    /**
     * Gets createdDate
     *
     * @return \DateTime
     */
    public function getCreatedDate()
    {
        return $this->container['createdDate'];
    }

    /**
     * Sets createdDate
     *
     * @param \DateTime $createdDate The date time when this item is created. Optional.
     *
     * @return $this
     */
    public function setCreatedDate($createdDate)
    {
        $this->container['createdDate'] = $createdDate;

        return $this;
    }

    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id An identifier for this item. Optional.
     *
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets storageETag
     *
     * @return string
     */
    public function getStorageETag()
    {
        return $this->container['storageETag'];
    }

    /**
     * Sets storageETag
     *
     * @param string $storageETag An opaque ETag used to synchronize with the version stored at server end. Optional.
     *
     * @return $this
     */
    public function setStorageETag($storageETag)
    {
        $this->container['storageETag'] = $storageETag;

        return $this;
    }

    /**
     * Gets url
     *
     * @return string
     */
    public function getUrl()
    {
        return $this->container['url'];
    }

    /**
     * Sets url
     *
     * @param string $url A URI which can be used to retrieve this item in its raw format. Optional. Note this is distinguished from other URIs that are present in a derived resource.
     *
     * @return $this
     */
    public function setUrl($url)
    {
        $this->container['url'] = $url;

        return $this;
    }

    /**
     * Gets blobDetails
     *
     * @return \FrankHouweling\AzureDevOpsClient\Symbol\Model\JsonBlobIdentifierWithBlocks
     */
    public function getBlobDetails()
    {
        return $this->container['blobDetails'];
    }

    /**
     * Sets blobDetails
     *
     * @param \FrankHouweling\AzureDevOpsClient\Symbol\Model\JsonBlobIdentifierWithBlocks $blobDetails Details of the blob formatted to be deserialized for symbol service.
     *
     * @return $this
     */
    public function setBlobDetails($blobDetails)
    {
        $this->container['blobDetails'] = $blobDetails;

        return $this;
    }

    /**
     * Gets blobIdentifier
     *
     * @return \FrankHouweling\AzureDevOpsClient\Symbol\Model\JsonBlobIdentifier
     */
    public function getBlobIdentifier()
    {
        return $this->container['blobIdentifier'];
    }

    /**
     * Sets blobIdentifier
     *
     * @param \FrankHouweling\AzureDevOpsClient\Symbol\Model\JsonBlobIdentifier $blobIdentifier A blob identifier of the symbol file to upload to this debug entry. This property is mostly used during creation of debug entry (a.k.a. symbol publishing) to allow the server to query the existence of the blob.
     *
     * @return $this
     */
    public function setBlobIdentifier($blobIdentifier)
    {
        $this->container['blobIdentifier'] = $blobIdentifier;

        return $this;
    }

    /**
     * Gets blobUri
     *
     * @return string
     */
    public function getBlobUri()
    {
        return $this->container['blobUri'];
    }

    /**
     * Sets blobUri
     *
     * @param string $blobUri The URI to get the symbol file. Provided by the server, the URI contains authentication information and is readily accessible by plain HTTP GET request. The client is recommended to retrieve the file as soon as it can since the URI will expire in a short period.
     *
     * @return $this
     */
    public function setBlobUri($blobUri)
    {
        $this->container['blobUri'] = $blobUri;

        return $this;
    }

    /**
     * Gets clientKey
     *
     * @return string
     */
    public function getClientKey()
    {
        return $this->container['clientKey'];
    }

    /**
     * Sets clientKey
     *
     * @param string $clientKey A key the client (debugger, for example) uses to find the debug entry. Note it is not unique for each different symbol file as it does not distinguish between those which only differ by information level.
     *
     * @return $this
     */
    public function setClientKey($clientKey)
    {
        $this->container['clientKey'] = $clientKey;

        return $this;
    }

    /**
     * Gets informationLevel
     *
     * @return string
     */
    public function getInformationLevel()
    {
        return $this->container['informationLevel'];
    }

    /**
     * Sets informationLevel
     *
     * @param string $informationLevel The information level this debug entry contains.
     *
     * @return $this
     */
    public function setInformationLevel($informationLevel)
    {
        $allowedValues = $this->getInformationLevelAllowableValues();
        if (!is_null($informationLevel) && !in_array($informationLevel, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'informationLevel', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['informationLevel'] = $informationLevel;

        return $this;
    }

    /**
     * Gets requestId
     *
     * @return string
     */
    public function getRequestId()
    {
        return $this->container['requestId'];
    }

    /**
     * Sets requestId
     *
     * @param string $requestId The identifier of symbol request to which this debug entry belongs.
     *
     * @return $this
     */
    public function setRequestId($requestId)
    {
        $this->container['requestId'] = $requestId;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string $status The status of debug entry.
     *
     * @return $this
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($status) && !in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'status', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


