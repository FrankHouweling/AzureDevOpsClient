<?php
/**
 * TestRunCounterInstance
 *
 * PHP version 5
 *
 * @category Class
 * @package  FrankHouweling\AzureDevOpsClient\Clt
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * CloudLoadTest
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0-preview
 * Contact: nugetvss@microsoft.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.11-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace FrankHouweling\AzureDevOpsClient\Clt\Model;

use \ArrayAccess;
use \FrankHouweling\AzureDevOpsClient\Clt\ObjectSerializer;

/**
 * TestRunCounterInstance Class Doc Comment
 *
 * @category Class
 * @description 
 * @package  FrankHouweling\AzureDevOpsClient\Clt
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TestRunCounterInstance implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'TestRunCounterInstance';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'categoryName' => 'string',
        'counterInstanceId' => 'string',
        'counterName' => 'string',
        'counterUnits' => 'string',
        'instanceName' => 'string',
        'isPreselectedCounter' => 'bool',
        'machineName' => 'string',
        'partOfCounterGroups' => 'string[]',
        'summaryData' => '\FrankHouweling\AzureDevOpsClient\Clt\Model\WebInstanceSummaryData',
        'uniqueName' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'categoryName' => null,
        'counterInstanceId' => null,
        'counterName' => null,
        'counterUnits' => null,
        'instanceName' => null,
        'isPreselectedCounter' => null,
        'machineName' => null,
        'partOfCounterGroups' => null,
        'summaryData' => null,
        'uniqueName' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'categoryName' => 'categoryName',
        'counterInstanceId' => 'counterInstanceId',
        'counterName' => 'counterName',
        'counterUnits' => 'counterUnits',
        'instanceName' => 'instanceName',
        'isPreselectedCounter' => 'isPreselectedCounter',
        'machineName' => 'machineName',
        'partOfCounterGroups' => 'partOfCounterGroups',
        'summaryData' => 'summaryData',
        'uniqueName' => 'uniqueName'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'categoryName' => 'setCategoryName',
        'counterInstanceId' => 'setCounterInstanceId',
        'counterName' => 'setCounterName',
        'counterUnits' => 'setCounterUnits',
        'instanceName' => 'setInstanceName',
        'isPreselectedCounter' => 'setIsPreselectedCounter',
        'machineName' => 'setMachineName',
        'partOfCounterGroups' => 'setPartOfCounterGroups',
        'summaryData' => 'setSummaryData',
        'uniqueName' => 'setUniqueName'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'categoryName' => 'getCategoryName',
        'counterInstanceId' => 'getCounterInstanceId',
        'counterName' => 'getCounterName',
        'counterUnits' => 'getCounterUnits',
        'instanceName' => 'getInstanceName',
        'isPreselectedCounter' => 'getIsPreselectedCounter',
        'machineName' => 'getMachineName',
        'partOfCounterGroups' => 'getPartOfCounterGroups',
        'summaryData' => 'getSummaryData',
        'uniqueName' => 'getUniqueName'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['categoryName'] = isset($data['categoryName']) ? $data['categoryName'] : null;
        $this->container['counterInstanceId'] = isset($data['counterInstanceId']) ? $data['counterInstanceId'] : null;
        $this->container['counterName'] = isset($data['counterName']) ? $data['counterName'] : null;
        $this->container['counterUnits'] = isset($data['counterUnits']) ? $data['counterUnits'] : null;
        $this->container['instanceName'] = isset($data['instanceName']) ? $data['instanceName'] : null;
        $this->container['isPreselectedCounter'] = isset($data['isPreselectedCounter']) ? $data['isPreselectedCounter'] : null;
        $this->container['machineName'] = isset($data['machineName']) ? $data['machineName'] : null;
        $this->container['partOfCounterGroups'] = isset($data['partOfCounterGroups']) ? $data['partOfCounterGroups'] : null;
        $this->container['summaryData'] = isset($data['summaryData']) ? $data['summaryData'] : null;
        $this->container['uniqueName'] = isset($data['uniqueName']) ? $data['uniqueName'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets categoryName
     *
     * @return string
     */
    public function getCategoryName()
    {
        return $this->container['categoryName'];
    }

    /**
     * Sets categoryName
     *
     * @param string $categoryName CategoryName for this counter
     *
     * @return $this
     */
    public function setCategoryName($categoryName)
    {
        $this->container['categoryName'] = $categoryName;

        return $this;
    }

    /**
     * Gets counterInstanceId
     *
     * @return string
     */
    public function getCounterInstanceId()
    {
        return $this->container['counterInstanceId'];
    }

    /**
     * Sets counterInstanceId
     *
     * @param string $counterInstanceId Combination of source and SourceInstanceId
     *
     * @return $this
     */
    public function setCounterInstanceId($counterInstanceId)
    {
        $this->container['counterInstanceId'] = $counterInstanceId;

        return $this;
    }

    /**
     * Gets counterName
     *
     * @return string
     */
    public function getCounterName()
    {
        return $this->container['counterName'];
    }

    /**
     * Sets counterName
     *
     * @param string $counterName Name of the counter Eg: Errors/Sec
     *
     * @return $this
     */
    public function setCounterName($counterName)
    {
        $this->container['counterName'] = $counterName;

        return $this;
    }

    /**
     * Gets counterUnits
     *
     * @return string
     */
    public function getCounterUnits()
    {
        return $this->container['counterUnits'];
    }

    /**
     * Sets counterUnits
     *
     * @param string $counterUnits Units for this counter. Empty string for mere numbers
     *
     * @return $this
     */
    public function setCounterUnits($counterUnits)
    {
        $this->container['counterUnits'] = $counterUnits;

        return $this;
    }

    /**
     * Gets instanceName
     *
     * @return string
     */
    public function getInstanceName()
    {
        return $this->container['instanceName'];
    }

    /**
     * Sets instanceName
     *
     * @param string $instanceName Instance Name Eg: _Avg,_Total etc
     *
     * @return $this
     */
    public function setInstanceName($instanceName)
    {
        $this->container['instanceName'] = $instanceName;

        return $this;
    }

    /**
     * Gets isPreselectedCounter
     *
     * @return bool
     */
    public function getIsPreselectedCounter()
    {
        return $this->container['isPreselectedCounter'];
    }

    /**
     * Sets isPreselectedCounter
     *
     * @param bool $isPreselectedCounter true if this counter instance is a default counter
     *
     * @return $this
     */
    public function setIsPreselectedCounter($isPreselectedCounter)
    {
        $this->container['isPreselectedCounter'] = $isPreselectedCounter;

        return $this;
    }

    /**
     * Gets machineName
     *
     * @return string
     */
    public function getMachineName()
    {
        return $this->container['machineName'];
    }

    /**
     * Sets machineName
     *
     * @param string $machineName Machine from where this counter was collected Used in case of machine specific counters like - Agent CPU and memory etc.
     *
     * @return $this
     */
    public function setMachineName($machineName)
    {
        $this->container['machineName'] = $machineName;

        return $this;
    }

    /**
     * Gets partOfCounterGroups
     *
     * @return string[]
     */
    public function getPartOfCounterGroups()
    {
        return $this->container['partOfCounterGroups'];
    }

    /**
     * Sets partOfCounterGroups
     *
     * @param string[] $partOfCounterGroups Counter Groups to which this counter instance is part of
     *
     * @return $this
     */
    public function setPartOfCounterGroups($partOfCounterGroups)
    {
        $this->container['partOfCounterGroups'] = $partOfCounterGroups;

        return $this;
    }

    /**
     * Gets summaryData
     *
     * @return \FrankHouweling\AzureDevOpsClient\Clt\Model\WebInstanceSummaryData
     */
    public function getSummaryData()
    {
        return $this->container['summaryData'];
    }

    /**
     * Sets summaryData
     *
     * @param \FrankHouweling\AzureDevOpsClient\Clt\Model\WebInstanceSummaryData $summaryData Summary result for this counter instance
     *
     * @return $this
     */
    public function setSummaryData($summaryData)
    {
        $this->container['summaryData'] = $summaryData;

        return $this;
    }

    /**
     * Gets uniqueName
     *
     * @return string
     */
    public function getUniqueName()
    {
        return $this->container['uniqueName'];
    }

    /**
     * Sets uniqueName
     *
     * @param string $uniqueName A unique name for this counter instance
     *
     * @return $this
     */
    public function setUniqueName($uniqueName)
    {
        $this->container['uniqueName'] = $uniqueName;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


