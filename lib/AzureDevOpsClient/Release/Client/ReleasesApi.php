<?php
/**
 * ReleasesApi
 * PHP version 5
 *
 * @category Class
 * @package  FrankHouweling\AzureDevOpsClient\Release
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Release
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0-preview
 * Contact: nugetvss@microsoft.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.11-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace FrankHouweling\AzureDevOpsClient\Release\Client;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use FrankHouweling\AzureDevOpsClient\Release\ApiException;
use FrankHouweling\AzureDevOpsClient\Release\Configuration;
use FrankHouweling\AzureDevOpsClient\Release\HeaderSelector;
use FrankHouweling\AzureDevOpsClient\Release\ObjectSerializer;

/**
 * ReleasesApi Class Doc Comment
 *
 * @category Class
 * @package  FrankHouweling\AzureDevOpsClient\Release
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ReleasesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation releasesCreate
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseStartMetadata $body Metadata to create a release. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FrankHouweling\AzureDevOpsClient\Release\Model\Release
     */
    public function releasesCreate($organization, $body, $project, $apiVersion)
    {
        list($response) = $this->releasesCreateWithHttpInfo($organization, $body, $project, $apiVersion);
        return $response;
    }

    /**
     * Operation releasesCreateWithHttpInfo
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseStartMetadata $body Metadata to create a release. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FrankHouweling\AzureDevOpsClient\Release\Model\Release, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesCreateWithHttpInfo($organization, $body, $project, $apiVersion)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Release\Model\Release';
        $request = $this->releasesCreateRequest($organization, $body, $project, $apiVersion);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FrankHouweling\AzureDevOpsClient\Release\Model\Release',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesCreateAsync
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseStartMetadata $body Metadata to create a release. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesCreateAsync($organization, $body, $project, $apiVersion)
    {
        return $this->releasesCreateAsyncWithHttpInfo($organization, $body, $project, $apiVersion)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesCreateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseStartMetadata $body Metadata to create a release. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesCreateAsyncWithHttpInfo($organization, $body, $project, $apiVersion)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Release\Model\Release';
        $request = $this->releasesCreateRequest($organization, $body, $project, $apiVersion);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesCreate'
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseStartMetadata $body Metadata to create a release. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesCreateRequest($organization, $body, $project, $apiVersion)
    {
        // verify the required parameter 'organization' is set
        if ($organization === null || (is_array($organization) && count($organization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization when calling releasesCreate'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling releasesCreate'
            );
        }
        // verify the required parameter 'project' is set
        if ($project === null || (is_array($project) && count($project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project when calling releasesCreate'
            );
        }
        // verify the required parameter 'apiVersion' is set
        if ($apiVersion === null || (is_array($apiVersion) && count($apiVersion) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiVersion when calling releasesCreate'
            );
        }

        $resourcePath = '/{organization}/{project}/_apis/release/releases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($apiVersion !== null) {
            $queryParams['api-version'] = ObjectSerializer::toQueryValue($apiVersion);
        }

        // path params
        if ($organization !== null) {
            $resourcePath = str_replace(
                '{' . 'organization' . '}',
                ObjectSerializer::toPathValue($organization),
                $resourcePath
            );
        }
        // path params
        if ($project !== null) {
            $resourcePath = str_replace(
                '{' . 'project' . '}',
                ObjectSerializer::toPathValue($project),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesGetLogs
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.2&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function releasesGetLogs($organization, $project, $releaseId, $apiVersion)
    {
        list($response) = $this->releasesGetLogsWithHttpInfo($organization, $project, $releaseId, $apiVersion);
        return $response;
    }

    /**
     * Operation releasesGetLogsWithHttpInfo
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.2&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesGetLogsWithHttpInfo($organization, $project, $releaseId, $apiVersion)
    {
        $returnType = 'string';
        $request = $this->releasesGetLogsRequest($organization, $project, $releaseId, $apiVersion);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesGetLogsAsync
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.2&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetLogsAsync($organization, $project, $releaseId, $apiVersion)
    {
        return $this->releasesGetLogsAsyncWithHttpInfo($organization, $project, $releaseId, $apiVersion)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesGetLogsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.2&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetLogsAsyncWithHttpInfo($organization, $project, $releaseId, $apiVersion)
    {
        $returnType = 'string';
        $request = $this->releasesGetLogsRequest($organization, $project, $releaseId, $apiVersion);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesGetLogs'
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.2&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesGetLogsRequest($organization, $project, $releaseId, $apiVersion)
    {
        // verify the required parameter 'organization' is set
        if ($organization === null || (is_array($organization) && count($organization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization when calling releasesGetLogs'
            );
        }
        // verify the required parameter 'project' is set
        if ($project === null || (is_array($project) && count($project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project when calling releasesGetLogs'
            );
        }
        // verify the required parameter 'releaseId' is set
        if ($releaseId === null || (is_array($releaseId) && count($releaseId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $releaseId when calling releasesGetLogs'
            );
        }
        // verify the required parameter 'apiVersion' is set
        if ($apiVersion === null || (is_array($apiVersion) && count($apiVersion) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiVersion when calling releasesGetLogs'
            );
        }

        $resourcePath = '/{organization}/{project}/_apis/release/releases/{releaseId}/logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($apiVersion !== null) {
            $queryParams['api-version'] = ObjectSerializer::toQueryValue($apiVersion);
        }

        // path params
        if ($organization !== null) {
            $resourcePath = str_replace(
                '{' . 'organization' . '}',
                ObjectSerializer::toPathValue($organization),
                $resourcePath
            );
        }
        // path params
        if ($project !== null) {
            $resourcePath = str_replace(
                '{' . 'project' . '}',
                ObjectSerializer::toPathValue($project),
                $resourcePath
            );
        }
        // path params
        if ($releaseId !== null) {
            $resourcePath = str_replace(
                '{' . 'releaseId' . '}',
                ObjectSerializer::toPathValue($releaseId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/zip']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/zip'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesGetReleaseEnvironment
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $environmentId Id of the release environment. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.6&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseEnvironment
     */
    public function releasesGetReleaseEnvironment($organization, $project, $releaseId, $environmentId, $apiVersion)
    {
        list($response) = $this->releasesGetReleaseEnvironmentWithHttpInfo($organization, $project, $releaseId, $environmentId, $apiVersion);
        return $response;
    }

    /**
     * Operation releasesGetReleaseEnvironmentWithHttpInfo
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $environmentId Id of the release environment. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.6&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseEnvironment, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesGetReleaseEnvironmentWithHttpInfo($organization, $project, $releaseId, $environmentId, $apiVersion)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseEnvironment';
        $request = $this->releasesGetReleaseEnvironmentRequest($organization, $project, $releaseId, $environmentId, $apiVersion);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseEnvironment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesGetReleaseEnvironmentAsync
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $environmentId Id of the release environment. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.6&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetReleaseEnvironmentAsync($organization, $project, $releaseId, $environmentId, $apiVersion)
    {
        return $this->releasesGetReleaseEnvironmentAsyncWithHttpInfo($organization, $project, $releaseId, $environmentId, $apiVersion)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesGetReleaseEnvironmentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $environmentId Id of the release environment. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.6&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetReleaseEnvironmentAsyncWithHttpInfo($organization, $project, $releaseId, $environmentId, $apiVersion)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseEnvironment';
        $request = $this->releasesGetReleaseEnvironmentRequest($organization, $project, $releaseId, $environmentId, $apiVersion);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesGetReleaseEnvironment'
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $environmentId Id of the release environment. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.6&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesGetReleaseEnvironmentRequest($organization, $project, $releaseId, $environmentId, $apiVersion)
    {
        // verify the required parameter 'organization' is set
        if ($organization === null || (is_array($organization) && count($organization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization when calling releasesGetReleaseEnvironment'
            );
        }
        // verify the required parameter 'project' is set
        if ($project === null || (is_array($project) && count($project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project when calling releasesGetReleaseEnvironment'
            );
        }
        // verify the required parameter 'releaseId' is set
        if ($releaseId === null || (is_array($releaseId) && count($releaseId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $releaseId when calling releasesGetReleaseEnvironment'
            );
        }
        // verify the required parameter 'environmentId' is set
        if ($environmentId === null || (is_array($environmentId) && count($environmentId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environmentId when calling releasesGetReleaseEnvironment'
            );
        }
        // verify the required parameter 'apiVersion' is set
        if ($apiVersion === null || (is_array($apiVersion) && count($apiVersion) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiVersion when calling releasesGetReleaseEnvironment'
            );
        }

        $resourcePath = '/{organization}/{project}/_apis/Release/releases/{releaseId}/environments/{environmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($apiVersion !== null) {
            $queryParams['api-version'] = ObjectSerializer::toQueryValue($apiVersion);
        }

        // path params
        if ($organization !== null) {
            $resourcePath = str_replace(
                '{' . 'organization' . '}',
                ObjectSerializer::toPathValue($organization),
                $resourcePath
            );
        }
        // path params
        if ($project !== null) {
            $resourcePath = str_replace(
                '{' . 'project' . '}',
                ObjectSerializer::toPathValue($project),
                $resourcePath
            );
        }
        // path params
        if ($releaseId !== null) {
            $resourcePath = str_replace(
                '{' . 'releaseId' . '}',
                ObjectSerializer::toPathValue($releaseId),
                $resourcePath
            );
        }
        // path params
        if ($environmentId !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentId' . '}',
                ObjectSerializer::toPathValue($environmentId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesGetReleaseRevision
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $definitionSnapshotRevision Definition snapshot revision number. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function releasesGetReleaseRevision($organization, $project, $releaseId, $definitionSnapshotRevision, $apiVersion)
    {
        list($response) = $this->releasesGetReleaseRevisionWithHttpInfo($organization, $project, $releaseId, $definitionSnapshotRevision, $apiVersion);
        return $response;
    }

    /**
     * Operation releasesGetReleaseRevisionWithHttpInfo
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $definitionSnapshotRevision Definition snapshot revision number. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesGetReleaseRevisionWithHttpInfo($organization, $project, $releaseId, $definitionSnapshotRevision, $apiVersion)
    {
        $returnType = 'string';
        $request = $this->releasesGetReleaseRevisionRequest($organization, $project, $releaseId, $definitionSnapshotRevision, $apiVersion);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesGetReleaseRevisionAsync
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $definitionSnapshotRevision Definition snapshot revision number. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetReleaseRevisionAsync($organization, $project, $releaseId, $definitionSnapshotRevision, $apiVersion)
    {
        return $this->releasesGetReleaseRevisionAsyncWithHttpInfo($organization, $project, $releaseId, $definitionSnapshotRevision, $apiVersion)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesGetReleaseRevisionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $definitionSnapshotRevision Definition snapshot revision number. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetReleaseRevisionAsyncWithHttpInfo($organization, $project, $releaseId, $definitionSnapshotRevision, $apiVersion)
    {
        $returnType = 'string';
        $request = $this->releasesGetReleaseRevisionRequest($organization, $project, $releaseId, $definitionSnapshotRevision, $apiVersion);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesGetReleaseRevision'
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $definitionSnapshotRevision Definition snapshot revision number. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesGetReleaseRevisionRequest($organization, $project, $releaseId, $definitionSnapshotRevision, $apiVersion)
    {
        // verify the required parameter 'organization' is set
        if ($organization === null || (is_array($organization) && count($organization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization when calling releasesGetReleaseRevision'
            );
        }
        // verify the required parameter 'project' is set
        if ($project === null || (is_array($project) && count($project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project when calling releasesGetReleaseRevision'
            );
        }
        // verify the required parameter 'releaseId' is set
        if ($releaseId === null || (is_array($releaseId) && count($releaseId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $releaseId when calling releasesGetReleaseRevision'
            );
        }
        // verify the required parameter 'definitionSnapshotRevision' is set
        if ($definitionSnapshotRevision === null || (is_array($definitionSnapshotRevision) && count($definitionSnapshotRevision) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $definitionSnapshotRevision when calling releasesGetReleaseRevision'
            );
        }
        // verify the required parameter 'apiVersion' is set
        if ($apiVersion === null || (is_array($apiVersion) && count($apiVersion) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiVersion when calling releasesGetReleaseRevision'
            );
        }

        $resourcePath = '/{organization}/{project}/_apis/release/releases/{releaseId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitionSnapshotRevision !== null) {
            $queryParams['definitionSnapshotRevision'] = ObjectSerializer::toQueryValue($definitionSnapshotRevision);
        }
        // query params
        if ($apiVersion !== null) {
            $queryParams['api-version'] = ObjectSerializer::toQueryValue($apiVersion);
        }

        // path params
        if ($organization !== null) {
            $resourcePath = str_replace(
                '{' . 'organization' . '}',
                ObjectSerializer::toPathValue($organization),
                $resourcePath
            );
        }
        // path params
        if ($project !== null) {
            $resourcePath = str_replace(
                '{' . 'project' . '}',
                ObjectSerializer::toPathValue($project),
                $resourcePath
            );
        }
        // path params
        if ($releaseId !== null) {
            $resourcePath = str_replace(
                '{' . 'releaseId' . '}',
                ObjectSerializer::toPathValue($releaseId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesGetTaskLog
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $environmentId Id of release environment. (required)
     * @param  int $releaseDeployPhaseId Release deploy phase Id. (required)
     * @param  int $taskId ReleaseTask Id for the log. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.2&#39; to use this version of the api. (required)
     * @param  int $startLine Starting line number for logs (optional)
     * @param  int $endLine Ending line number for logs (optional)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function releasesGetTaskLog($organization, $project, $releaseId, $environmentId, $releaseDeployPhaseId, $taskId, $apiVersion, $startLine = null, $endLine = null)
    {
        list($response) = $this->releasesGetTaskLogWithHttpInfo($organization, $project, $releaseId, $environmentId, $releaseDeployPhaseId, $taskId, $apiVersion, $startLine, $endLine);
        return $response;
    }

    /**
     * Operation releasesGetTaskLogWithHttpInfo
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $environmentId Id of release environment. (required)
     * @param  int $releaseDeployPhaseId Release deploy phase Id. (required)
     * @param  int $taskId ReleaseTask Id for the log. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.2&#39; to use this version of the api. (required)
     * @param  int $startLine Starting line number for logs (optional)
     * @param  int $endLine Ending line number for logs (optional)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesGetTaskLogWithHttpInfo($organization, $project, $releaseId, $environmentId, $releaseDeployPhaseId, $taskId, $apiVersion, $startLine = null, $endLine = null)
    {
        $returnType = 'string';
        $request = $this->releasesGetTaskLogRequest($organization, $project, $releaseId, $environmentId, $releaseDeployPhaseId, $taskId, $apiVersion, $startLine, $endLine);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesGetTaskLogAsync
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $environmentId Id of release environment. (required)
     * @param  int $releaseDeployPhaseId Release deploy phase Id. (required)
     * @param  int $taskId ReleaseTask Id for the log. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.2&#39; to use this version of the api. (required)
     * @param  int $startLine Starting line number for logs (optional)
     * @param  int $endLine Ending line number for logs (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetTaskLogAsync($organization, $project, $releaseId, $environmentId, $releaseDeployPhaseId, $taskId, $apiVersion, $startLine = null, $endLine = null)
    {
        return $this->releasesGetTaskLogAsyncWithHttpInfo($organization, $project, $releaseId, $environmentId, $releaseDeployPhaseId, $taskId, $apiVersion, $startLine, $endLine)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesGetTaskLogAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $environmentId Id of release environment. (required)
     * @param  int $releaseDeployPhaseId Release deploy phase Id. (required)
     * @param  int $taskId ReleaseTask Id for the log. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.2&#39; to use this version of the api. (required)
     * @param  int $startLine Starting line number for logs (optional)
     * @param  int $endLine Ending line number for logs (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetTaskLogAsyncWithHttpInfo($organization, $project, $releaseId, $environmentId, $releaseDeployPhaseId, $taskId, $apiVersion, $startLine = null, $endLine = null)
    {
        $returnType = 'string';
        $request = $this->releasesGetTaskLogRequest($organization, $project, $releaseId, $environmentId, $releaseDeployPhaseId, $taskId, $apiVersion, $startLine, $endLine);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesGetTaskLog'
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $environmentId Id of release environment. (required)
     * @param  int $releaseDeployPhaseId Release deploy phase Id. (required)
     * @param  int $taskId ReleaseTask Id for the log. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.2&#39; to use this version of the api. (required)
     * @param  int $startLine Starting line number for logs (optional)
     * @param  int $endLine Ending line number for logs (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesGetTaskLogRequest($organization, $project, $releaseId, $environmentId, $releaseDeployPhaseId, $taskId, $apiVersion, $startLine = null, $endLine = null)
    {
        // verify the required parameter 'organization' is set
        if ($organization === null || (is_array($organization) && count($organization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization when calling releasesGetTaskLog'
            );
        }
        // verify the required parameter 'project' is set
        if ($project === null || (is_array($project) && count($project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project when calling releasesGetTaskLog'
            );
        }
        // verify the required parameter 'releaseId' is set
        if ($releaseId === null || (is_array($releaseId) && count($releaseId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $releaseId when calling releasesGetTaskLog'
            );
        }
        // verify the required parameter 'environmentId' is set
        if ($environmentId === null || (is_array($environmentId) && count($environmentId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environmentId when calling releasesGetTaskLog'
            );
        }
        // verify the required parameter 'releaseDeployPhaseId' is set
        if ($releaseDeployPhaseId === null || (is_array($releaseDeployPhaseId) && count($releaseDeployPhaseId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $releaseDeployPhaseId when calling releasesGetTaskLog'
            );
        }
        // verify the required parameter 'taskId' is set
        if ($taskId === null || (is_array($taskId) && count($taskId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskId when calling releasesGetTaskLog'
            );
        }
        // verify the required parameter 'apiVersion' is set
        if ($apiVersion === null || (is_array($apiVersion) && count($apiVersion) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiVersion when calling releasesGetTaskLog'
            );
        }

        $resourcePath = '/{organization}/{project}/_apis/release/releases/{releaseId}/environments/{environmentId}/deployPhases/{releaseDeployPhaseId}/tasks/{taskId}/logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($startLine !== null) {
            $queryParams['startLine'] = ObjectSerializer::toQueryValue($startLine);
        }
        // query params
        if ($endLine !== null) {
            $queryParams['endLine'] = ObjectSerializer::toQueryValue($endLine);
        }
        // query params
        if ($apiVersion !== null) {
            $queryParams['api-version'] = ObjectSerializer::toQueryValue($apiVersion);
        }

        // path params
        if ($organization !== null) {
            $resourcePath = str_replace(
                '{' . 'organization' . '}',
                ObjectSerializer::toPathValue($organization),
                $resourcePath
            );
        }
        // path params
        if ($project !== null) {
            $resourcePath = str_replace(
                '{' . 'project' . '}',
                ObjectSerializer::toPathValue($project),
                $resourcePath
            );
        }
        // path params
        if ($releaseId !== null) {
            $resourcePath = str_replace(
                '{' . 'releaseId' . '}',
                ObjectSerializer::toPathValue($releaseId),
                $resourcePath
            );
        }
        // path params
        if ($environmentId !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentId' . '}',
                ObjectSerializer::toPathValue($environmentId),
                $resourcePath
            );
        }
        // path params
        if ($releaseDeployPhaseId !== null) {
            $resourcePath = str_replace(
                '{' . 'releaseDeployPhaseId' . '}',
                ObjectSerializer::toPathValue($releaseDeployPhaseId),
                $resourcePath
            );
        }
        // path params
        if ($taskId !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($taskId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesList
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     * @param  int $definitionId Releases from this release definition Id. (optional)
     * @param  int $definitionEnvironmentId  (optional)
     * @param  string $searchText Releases with names containing searchText. (optional)
     * @param  string $createdBy Releases created by this user. (optional)
     * @param  string $statusFilter Releases that have this status. (optional)
     * @param  int $environmentStatusFilter  (optional)
     * @param  \DateTime $minCreatedTime Releases that were created after this time. (optional)
     * @param  \DateTime $maxCreatedTime Releases that were created before this time. (optional)
     * @param  string $queryOrder Gets the results in the defined order of created date for releases. Default is descending. (optional)
     * @param  int $top Number of releases to get. Default is 50. (optional)
     * @param  int $continuationToken Gets the releases after the continuation token provided. (optional)
     * @param  string $expand The property that should be expanded in the list of releases. (optional)
     * @param  string $artifactTypeId Releases with given artifactTypeId will be returned. Values can be Build, Jenkins, GitHub, Nuget, Team Build (external), ExternalTFSBuild, Git, TFVC, ExternalTfsXamlBuild. (optional)
     * @param  string $sourceId Unique identifier of the artifact used. e.g. For build it would be {projectGuid}:{BuildDefinitionId}, for Jenkins it would be {JenkinsConnectionId}:{JenkinsDefinitionId}, for TfsOnPrem it would be {TfsOnPremConnectionId}:{ProjectName}:{TfsOnPremDefinitionId}. For third-party artifacts e.g. TeamCity, BitBucket you may refer &#39;uniqueSourceIdentifier&#39; inside vss-extension.json https://github.com/Microsoft/vsts-rm-extensions/blob/master/Extensions. (optional)
     * @param  string $artifactVersionId Releases with given artifactVersionId will be returned. E.g. in case of Build artifactType, it is buildId. (optional)
     * @param  string $sourceBranchFilter Releases with given sourceBranchFilter will be returned. (optional)
     * @param  bool $isDeleted Gets the soft deleted releases, if true. (optional)
     * @param  string $tagFilter A comma-delimited list of tags. Only releases with these tags will be returned. (optional)
     * @param  string $propertyFilters A comma-delimited list of extended properties to be retrieved. If set, the returned Releases will contain values for the specified property Ids (if they exist). If not set, properties will not be included. Note that this will not filter out any Release from results irrespective of whether it has property set or not. (optional)
     * @param  string $releaseIdFilter A comma-delimited list of releases Ids. Only releases with these Ids will be returned. (optional)
     * @param  string $path Releases under this folder path will be returned (optional)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FrankHouweling\AzureDevOpsClient\Release\Model\Release[]
     */
    public function releasesList($organization, $project, $apiVersion, $definitionId = null, $definitionEnvironmentId = null, $searchText = null, $createdBy = null, $statusFilter = null, $environmentStatusFilter = null, $minCreatedTime = null, $maxCreatedTime = null, $queryOrder = null, $top = null, $continuationToken = null, $expand = null, $artifactTypeId = null, $sourceId = null, $artifactVersionId = null, $sourceBranchFilter = null, $isDeleted = null, $tagFilter = null, $propertyFilters = null, $releaseIdFilter = null, $path = null)
    {
        list($response) = $this->releasesListWithHttpInfo($organization, $project, $apiVersion, $definitionId, $definitionEnvironmentId, $searchText, $createdBy, $statusFilter, $environmentStatusFilter, $minCreatedTime, $maxCreatedTime, $queryOrder, $top, $continuationToken, $expand, $artifactTypeId, $sourceId, $artifactVersionId, $sourceBranchFilter, $isDeleted, $tagFilter, $propertyFilters, $releaseIdFilter, $path);
        return $response;
    }

    /**
     * Operation releasesListWithHttpInfo
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     * @param  int $definitionId Releases from this release definition Id. (optional)
     * @param  int $definitionEnvironmentId  (optional)
     * @param  string $searchText Releases with names containing searchText. (optional)
     * @param  string $createdBy Releases created by this user. (optional)
     * @param  string $statusFilter Releases that have this status. (optional)
     * @param  int $environmentStatusFilter  (optional)
     * @param  \DateTime $minCreatedTime Releases that were created after this time. (optional)
     * @param  \DateTime $maxCreatedTime Releases that were created before this time. (optional)
     * @param  string $queryOrder Gets the results in the defined order of created date for releases. Default is descending. (optional)
     * @param  int $top Number of releases to get. Default is 50. (optional)
     * @param  int $continuationToken Gets the releases after the continuation token provided. (optional)
     * @param  string $expand The property that should be expanded in the list of releases. (optional)
     * @param  string $artifactTypeId Releases with given artifactTypeId will be returned. Values can be Build, Jenkins, GitHub, Nuget, Team Build (external), ExternalTFSBuild, Git, TFVC, ExternalTfsXamlBuild. (optional)
     * @param  string $sourceId Unique identifier of the artifact used. e.g. For build it would be {projectGuid}:{BuildDefinitionId}, for Jenkins it would be {JenkinsConnectionId}:{JenkinsDefinitionId}, for TfsOnPrem it would be {TfsOnPremConnectionId}:{ProjectName}:{TfsOnPremDefinitionId}. For third-party artifacts e.g. TeamCity, BitBucket you may refer &#39;uniqueSourceIdentifier&#39; inside vss-extension.json https://github.com/Microsoft/vsts-rm-extensions/blob/master/Extensions. (optional)
     * @param  string $artifactVersionId Releases with given artifactVersionId will be returned. E.g. in case of Build artifactType, it is buildId. (optional)
     * @param  string $sourceBranchFilter Releases with given sourceBranchFilter will be returned. (optional)
     * @param  bool $isDeleted Gets the soft deleted releases, if true. (optional)
     * @param  string $tagFilter A comma-delimited list of tags. Only releases with these tags will be returned. (optional)
     * @param  string $propertyFilters A comma-delimited list of extended properties to be retrieved. If set, the returned Releases will contain values for the specified property Ids (if they exist). If not set, properties will not be included. Note that this will not filter out any Release from results irrespective of whether it has property set or not. (optional)
     * @param  string $releaseIdFilter A comma-delimited list of releases Ids. Only releases with these Ids will be returned. (optional)
     * @param  string $path Releases under this folder path will be returned (optional)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FrankHouweling\AzureDevOpsClient\Release\Model\Release[], HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesListWithHttpInfo($organization, $project, $apiVersion, $definitionId = null, $definitionEnvironmentId = null, $searchText = null, $createdBy = null, $statusFilter = null, $environmentStatusFilter = null, $minCreatedTime = null, $maxCreatedTime = null, $queryOrder = null, $top = null, $continuationToken = null, $expand = null, $artifactTypeId = null, $sourceId = null, $artifactVersionId = null, $sourceBranchFilter = null, $isDeleted = null, $tagFilter = null, $propertyFilters = null, $releaseIdFilter = null, $path = null)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Release\Model\Release[]';
        $request = $this->releasesListRequest($organization, $project, $apiVersion, $definitionId, $definitionEnvironmentId, $searchText, $createdBy, $statusFilter, $environmentStatusFilter, $minCreatedTime, $maxCreatedTime, $queryOrder, $top, $continuationToken, $expand, $artifactTypeId, $sourceId, $artifactVersionId, $sourceBranchFilter, $isDeleted, $tagFilter, $propertyFilters, $releaseIdFilter, $path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FrankHouweling\AzureDevOpsClient\Release\Model\Release[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesListAsync
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     * @param  int $definitionId Releases from this release definition Id. (optional)
     * @param  int $definitionEnvironmentId  (optional)
     * @param  string $searchText Releases with names containing searchText. (optional)
     * @param  string $createdBy Releases created by this user. (optional)
     * @param  string $statusFilter Releases that have this status. (optional)
     * @param  int $environmentStatusFilter  (optional)
     * @param  \DateTime $minCreatedTime Releases that were created after this time. (optional)
     * @param  \DateTime $maxCreatedTime Releases that were created before this time. (optional)
     * @param  string $queryOrder Gets the results in the defined order of created date for releases. Default is descending. (optional)
     * @param  int $top Number of releases to get. Default is 50. (optional)
     * @param  int $continuationToken Gets the releases after the continuation token provided. (optional)
     * @param  string $expand The property that should be expanded in the list of releases. (optional)
     * @param  string $artifactTypeId Releases with given artifactTypeId will be returned. Values can be Build, Jenkins, GitHub, Nuget, Team Build (external), ExternalTFSBuild, Git, TFVC, ExternalTfsXamlBuild. (optional)
     * @param  string $sourceId Unique identifier of the artifact used. e.g. For build it would be {projectGuid}:{BuildDefinitionId}, for Jenkins it would be {JenkinsConnectionId}:{JenkinsDefinitionId}, for TfsOnPrem it would be {TfsOnPremConnectionId}:{ProjectName}:{TfsOnPremDefinitionId}. For third-party artifacts e.g. TeamCity, BitBucket you may refer &#39;uniqueSourceIdentifier&#39; inside vss-extension.json https://github.com/Microsoft/vsts-rm-extensions/blob/master/Extensions. (optional)
     * @param  string $artifactVersionId Releases with given artifactVersionId will be returned. E.g. in case of Build artifactType, it is buildId. (optional)
     * @param  string $sourceBranchFilter Releases with given sourceBranchFilter will be returned. (optional)
     * @param  bool $isDeleted Gets the soft deleted releases, if true. (optional)
     * @param  string $tagFilter A comma-delimited list of tags. Only releases with these tags will be returned. (optional)
     * @param  string $propertyFilters A comma-delimited list of extended properties to be retrieved. If set, the returned Releases will contain values for the specified property Ids (if they exist). If not set, properties will not be included. Note that this will not filter out any Release from results irrespective of whether it has property set or not. (optional)
     * @param  string $releaseIdFilter A comma-delimited list of releases Ids. Only releases with these Ids will be returned. (optional)
     * @param  string $path Releases under this folder path will be returned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesListAsync($organization, $project, $apiVersion, $definitionId = null, $definitionEnvironmentId = null, $searchText = null, $createdBy = null, $statusFilter = null, $environmentStatusFilter = null, $minCreatedTime = null, $maxCreatedTime = null, $queryOrder = null, $top = null, $continuationToken = null, $expand = null, $artifactTypeId = null, $sourceId = null, $artifactVersionId = null, $sourceBranchFilter = null, $isDeleted = null, $tagFilter = null, $propertyFilters = null, $releaseIdFilter = null, $path = null)
    {
        return $this->releasesListAsyncWithHttpInfo($organization, $project, $apiVersion, $definitionId, $definitionEnvironmentId, $searchText, $createdBy, $statusFilter, $environmentStatusFilter, $minCreatedTime, $maxCreatedTime, $queryOrder, $top, $continuationToken, $expand, $artifactTypeId, $sourceId, $artifactVersionId, $sourceBranchFilter, $isDeleted, $tagFilter, $propertyFilters, $releaseIdFilter, $path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesListAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     * @param  int $definitionId Releases from this release definition Id. (optional)
     * @param  int $definitionEnvironmentId  (optional)
     * @param  string $searchText Releases with names containing searchText. (optional)
     * @param  string $createdBy Releases created by this user. (optional)
     * @param  string $statusFilter Releases that have this status. (optional)
     * @param  int $environmentStatusFilter  (optional)
     * @param  \DateTime $minCreatedTime Releases that were created after this time. (optional)
     * @param  \DateTime $maxCreatedTime Releases that were created before this time. (optional)
     * @param  string $queryOrder Gets the results in the defined order of created date for releases. Default is descending. (optional)
     * @param  int $top Number of releases to get. Default is 50. (optional)
     * @param  int $continuationToken Gets the releases after the continuation token provided. (optional)
     * @param  string $expand The property that should be expanded in the list of releases. (optional)
     * @param  string $artifactTypeId Releases with given artifactTypeId will be returned. Values can be Build, Jenkins, GitHub, Nuget, Team Build (external), ExternalTFSBuild, Git, TFVC, ExternalTfsXamlBuild. (optional)
     * @param  string $sourceId Unique identifier of the artifact used. e.g. For build it would be {projectGuid}:{BuildDefinitionId}, for Jenkins it would be {JenkinsConnectionId}:{JenkinsDefinitionId}, for TfsOnPrem it would be {TfsOnPremConnectionId}:{ProjectName}:{TfsOnPremDefinitionId}. For third-party artifacts e.g. TeamCity, BitBucket you may refer &#39;uniqueSourceIdentifier&#39; inside vss-extension.json https://github.com/Microsoft/vsts-rm-extensions/blob/master/Extensions. (optional)
     * @param  string $artifactVersionId Releases with given artifactVersionId will be returned. E.g. in case of Build artifactType, it is buildId. (optional)
     * @param  string $sourceBranchFilter Releases with given sourceBranchFilter will be returned. (optional)
     * @param  bool $isDeleted Gets the soft deleted releases, if true. (optional)
     * @param  string $tagFilter A comma-delimited list of tags. Only releases with these tags will be returned. (optional)
     * @param  string $propertyFilters A comma-delimited list of extended properties to be retrieved. If set, the returned Releases will contain values for the specified property Ids (if they exist). If not set, properties will not be included. Note that this will not filter out any Release from results irrespective of whether it has property set or not. (optional)
     * @param  string $releaseIdFilter A comma-delimited list of releases Ids. Only releases with these Ids will be returned. (optional)
     * @param  string $path Releases under this folder path will be returned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesListAsyncWithHttpInfo($organization, $project, $apiVersion, $definitionId = null, $definitionEnvironmentId = null, $searchText = null, $createdBy = null, $statusFilter = null, $environmentStatusFilter = null, $minCreatedTime = null, $maxCreatedTime = null, $queryOrder = null, $top = null, $continuationToken = null, $expand = null, $artifactTypeId = null, $sourceId = null, $artifactVersionId = null, $sourceBranchFilter = null, $isDeleted = null, $tagFilter = null, $propertyFilters = null, $releaseIdFilter = null, $path = null)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Release\Model\Release[]';
        $request = $this->releasesListRequest($organization, $project, $apiVersion, $definitionId, $definitionEnvironmentId, $searchText, $createdBy, $statusFilter, $environmentStatusFilter, $minCreatedTime, $maxCreatedTime, $queryOrder, $top, $continuationToken, $expand, $artifactTypeId, $sourceId, $artifactVersionId, $sourceBranchFilter, $isDeleted, $tagFilter, $propertyFilters, $releaseIdFilter, $path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesList'
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     * @param  int $definitionId Releases from this release definition Id. (optional)
     * @param  int $definitionEnvironmentId  (optional)
     * @param  string $searchText Releases with names containing searchText. (optional)
     * @param  string $createdBy Releases created by this user. (optional)
     * @param  string $statusFilter Releases that have this status. (optional)
     * @param  int $environmentStatusFilter  (optional)
     * @param  \DateTime $minCreatedTime Releases that were created after this time. (optional)
     * @param  \DateTime $maxCreatedTime Releases that were created before this time. (optional)
     * @param  string $queryOrder Gets the results in the defined order of created date for releases. Default is descending. (optional)
     * @param  int $top Number of releases to get. Default is 50. (optional)
     * @param  int $continuationToken Gets the releases after the continuation token provided. (optional)
     * @param  string $expand The property that should be expanded in the list of releases. (optional)
     * @param  string $artifactTypeId Releases with given artifactTypeId will be returned. Values can be Build, Jenkins, GitHub, Nuget, Team Build (external), ExternalTFSBuild, Git, TFVC, ExternalTfsXamlBuild. (optional)
     * @param  string $sourceId Unique identifier of the artifact used. e.g. For build it would be {projectGuid}:{BuildDefinitionId}, for Jenkins it would be {JenkinsConnectionId}:{JenkinsDefinitionId}, for TfsOnPrem it would be {TfsOnPremConnectionId}:{ProjectName}:{TfsOnPremDefinitionId}. For third-party artifacts e.g. TeamCity, BitBucket you may refer &#39;uniqueSourceIdentifier&#39; inside vss-extension.json https://github.com/Microsoft/vsts-rm-extensions/blob/master/Extensions. (optional)
     * @param  string $artifactVersionId Releases with given artifactVersionId will be returned. E.g. in case of Build artifactType, it is buildId. (optional)
     * @param  string $sourceBranchFilter Releases with given sourceBranchFilter will be returned. (optional)
     * @param  bool $isDeleted Gets the soft deleted releases, if true. (optional)
     * @param  string $tagFilter A comma-delimited list of tags. Only releases with these tags will be returned. (optional)
     * @param  string $propertyFilters A comma-delimited list of extended properties to be retrieved. If set, the returned Releases will contain values for the specified property Ids (if they exist). If not set, properties will not be included. Note that this will not filter out any Release from results irrespective of whether it has property set or not. (optional)
     * @param  string $releaseIdFilter A comma-delimited list of releases Ids. Only releases with these Ids will be returned. (optional)
     * @param  string $path Releases under this folder path will be returned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesListRequest($organization, $project, $apiVersion, $definitionId = null, $definitionEnvironmentId = null, $searchText = null, $createdBy = null, $statusFilter = null, $environmentStatusFilter = null, $minCreatedTime = null, $maxCreatedTime = null, $queryOrder = null, $top = null, $continuationToken = null, $expand = null, $artifactTypeId = null, $sourceId = null, $artifactVersionId = null, $sourceBranchFilter = null, $isDeleted = null, $tagFilter = null, $propertyFilters = null, $releaseIdFilter = null, $path = null)
    {
        // verify the required parameter 'organization' is set
        if ($organization === null || (is_array($organization) && count($organization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization when calling releasesList'
            );
        }
        // verify the required parameter 'project' is set
        if ($project === null || (is_array($project) && count($project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project when calling releasesList'
            );
        }
        // verify the required parameter 'apiVersion' is set
        if ($apiVersion === null || (is_array($apiVersion) && count($apiVersion) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiVersion when calling releasesList'
            );
        }

        $resourcePath = '/{organization}/{project}/_apis/release/releases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($definitionId !== null) {
            $queryParams['definitionId'] = ObjectSerializer::toQueryValue($definitionId);
        }
        // query params
        if ($definitionEnvironmentId !== null) {
            $queryParams['definitionEnvironmentId'] = ObjectSerializer::toQueryValue($definitionEnvironmentId);
        }
        // query params
        if ($searchText !== null) {
            $queryParams['searchText'] = ObjectSerializer::toQueryValue($searchText);
        }
        // query params
        if ($createdBy !== null) {
            $queryParams['createdBy'] = ObjectSerializer::toQueryValue($createdBy);
        }
        // query params
        if ($statusFilter !== null) {
            $queryParams['statusFilter'] = ObjectSerializer::toQueryValue($statusFilter);
        }
        // query params
        if ($environmentStatusFilter !== null) {
            $queryParams['environmentStatusFilter'] = ObjectSerializer::toQueryValue($environmentStatusFilter);
        }
        // query params
        if ($minCreatedTime !== null) {
            $queryParams['minCreatedTime'] = ObjectSerializer::toQueryValue($minCreatedTime);
        }
        // query params
        if ($maxCreatedTime !== null) {
            $queryParams['maxCreatedTime'] = ObjectSerializer::toQueryValue($maxCreatedTime);
        }
        // query params
        if ($queryOrder !== null) {
            $queryParams['queryOrder'] = ObjectSerializer::toQueryValue($queryOrder);
        }
        // query params
        if ($top !== null) {
            $queryParams['$top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($continuationToken !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuationToken);
        }
        // query params
        if ($expand !== null) {
            $queryParams['$expand'] = ObjectSerializer::toQueryValue($expand);
        }
        // query params
        if ($artifactTypeId !== null) {
            $queryParams['artifactTypeId'] = ObjectSerializer::toQueryValue($artifactTypeId);
        }
        // query params
        if ($sourceId !== null) {
            $queryParams['sourceId'] = ObjectSerializer::toQueryValue($sourceId);
        }
        // query params
        if ($artifactVersionId !== null) {
            $queryParams['artifactVersionId'] = ObjectSerializer::toQueryValue($artifactVersionId);
        }
        // query params
        if ($sourceBranchFilter !== null) {
            $queryParams['sourceBranchFilter'] = ObjectSerializer::toQueryValue($sourceBranchFilter);
        }
        // query params
        if ($isDeleted !== null) {
            $queryParams['isDeleted'] = ObjectSerializer::toQueryValue($isDeleted);
        }
        // query params
        if ($tagFilter !== null) {
            $queryParams['tagFilter'] = ObjectSerializer::toQueryValue($tagFilter);
        }
        // query params
        if ($propertyFilters !== null) {
            $queryParams['propertyFilters'] = ObjectSerializer::toQueryValue($propertyFilters);
        }
        // query params
        if ($releaseIdFilter !== null) {
            $queryParams['releaseIdFilter'] = ObjectSerializer::toQueryValue($releaseIdFilter);
        }
        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($apiVersion !== null) {
            $queryParams['api-version'] = ObjectSerializer::toQueryValue($apiVersion);
        }

        // path params
        if ($organization !== null) {
            $resourcePath = str_replace(
                '{' . 'organization' . '}',
                ObjectSerializer::toPathValue($organization),
                $resourcePath
            );
        }
        // path params
        if ($project !== null) {
            $resourcePath = str_replace(
                '{' . 'project' . '}',
                ObjectSerializer::toPathValue($project),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesUpdateRelease
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\Release $body Release object for update. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release to update. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FrankHouweling\AzureDevOpsClient\Release\Model\Release
     */
    public function releasesUpdateRelease($organization, $body, $project, $releaseId, $apiVersion)
    {
        list($response) = $this->releasesUpdateReleaseWithHttpInfo($organization, $body, $project, $releaseId, $apiVersion);
        return $response;
    }

    /**
     * Operation releasesUpdateReleaseWithHttpInfo
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\Release $body Release object for update. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release to update. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FrankHouweling\AzureDevOpsClient\Release\Model\Release, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesUpdateReleaseWithHttpInfo($organization, $body, $project, $releaseId, $apiVersion)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Release\Model\Release';
        $request = $this->releasesUpdateReleaseRequest($organization, $body, $project, $releaseId, $apiVersion);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FrankHouweling\AzureDevOpsClient\Release\Model\Release',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesUpdateReleaseAsync
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\Release $body Release object for update. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release to update. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesUpdateReleaseAsync($organization, $body, $project, $releaseId, $apiVersion)
    {
        return $this->releasesUpdateReleaseAsyncWithHttpInfo($organization, $body, $project, $releaseId, $apiVersion)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesUpdateReleaseAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\Release $body Release object for update. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release to update. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesUpdateReleaseAsyncWithHttpInfo($organization, $body, $project, $releaseId, $apiVersion)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Release\Model\Release';
        $request = $this->releasesUpdateReleaseRequest($organization, $body, $project, $releaseId, $apiVersion);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesUpdateRelease'
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\Release $body Release object for update. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release to update. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesUpdateReleaseRequest($organization, $body, $project, $releaseId, $apiVersion)
    {
        // verify the required parameter 'organization' is set
        if ($organization === null || (is_array($organization) && count($organization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization when calling releasesUpdateRelease'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling releasesUpdateRelease'
            );
        }
        // verify the required parameter 'project' is set
        if ($project === null || (is_array($project) && count($project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project when calling releasesUpdateRelease'
            );
        }
        // verify the required parameter 'releaseId' is set
        if ($releaseId === null || (is_array($releaseId) && count($releaseId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $releaseId when calling releasesUpdateRelease'
            );
        }
        // verify the required parameter 'apiVersion' is set
        if ($apiVersion === null || (is_array($apiVersion) && count($apiVersion) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiVersion when calling releasesUpdateRelease'
            );
        }

        $resourcePath = '/{organization}/{project}/_apis/release/releases/{releaseId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($apiVersion !== null) {
            $queryParams['api-version'] = ObjectSerializer::toQueryValue($apiVersion);
        }

        // path params
        if ($organization !== null) {
            $resourcePath = str_replace(
                '{' . 'organization' . '}',
                ObjectSerializer::toPathValue($organization),
                $resourcePath
            );
        }
        // path params
        if ($project !== null) {
            $resourcePath = str_replace(
                '{' . 'project' . '}',
                ObjectSerializer::toPathValue($project),
                $resourcePath
            );
        }
        // path params
        if ($releaseId !== null) {
            $resourcePath = str_replace(
                '{' . 'releaseId' . '}',
                ObjectSerializer::toPathValue($releaseId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesUpdateReleaseEnvironment
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseEnvironmentUpdateMetadata $body Environment update meta data. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $environmentId Id of release environment. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.6&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseEnvironment
     */
    public function releasesUpdateReleaseEnvironment($organization, $body, $project, $releaseId, $environmentId, $apiVersion)
    {
        list($response) = $this->releasesUpdateReleaseEnvironmentWithHttpInfo($organization, $body, $project, $releaseId, $environmentId, $apiVersion);
        return $response;
    }

    /**
     * Operation releasesUpdateReleaseEnvironmentWithHttpInfo
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseEnvironmentUpdateMetadata $body Environment update meta data. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $environmentId Id of release environment. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.6&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseEnvironment, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesUpdateReleaseEnvironmentWithHttpInfo($organization, $body, $project, $releaseId, $environmentId, $apiVersion)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseEnvironment';
        $request = $this->releasesUpdateReleaseEnvironmentRequest($organization, $body, $project, $releaseId, $environmentId, $apiVersion);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseEnvironment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesUpdateReleaseEnvironmentAsync
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseEnvironmentUpdateMetadata $body Environment update meta data. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $environmentId Id of release environment. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.6&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesUpdateReleaseEnvironmentAsync($organization, $body, $project, $releaseId, $environmentId, $apiVersion)
    {
        return $this->releasesUpdateReleaseEnvironmentAsyncWithHttpInfo($organization, $body, $project, $releaseId, $environmentId, $apiVersion)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesUpdateReleaseEnvironmentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseEnvironmentUpdateMetadata $body Environment update meta data. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $environmentId Id of release environment. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.6&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesUpdateReleaseEnvironmentAsyncWithHttpInfo($organization, $body, $project, $releaseId, $environmentId, $apiVersion)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseEnvironment';
        $request = $this->releasesUpdateReleaseEnvironmentRequest($organization, $body, $project, $releaseId, $environmentId, $apiVersion);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesUpdateReleaseEnvironment'
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseEnvironmentUpdateMetadata $body Environment update meta data. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release. (required)
     * @param  int $environmentId Id of release environment. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.6&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesUpdateReleaseEnvironmentRequest($organization, $body, $project, $releaseId, $environmentId, $apiVersion)
    {
        // verify the required parameter 'organization' is set
        if ($organization === null || (is_array($organization) && count($organization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization when calling releasesUpdateReleaseEnvironment'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling releasesUpdateReleaseEnvironment'
            );
        }
        // verify the required parameter 'project' is set
        if ($project === null || (is_array($project) && count($project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project when calling releasesUpdateReleaseEnvironment'
            );
        }
        // verify the required parameter 'releaseId' is set
        if ($releaseId === null || (is_array($releaseId) && count($releaseId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $releaseId when calling releasesUpdateReleaseEnvironment'
            );
        }
        // verify the required parameter 'environmentId' is set
        if ($environmentId === null || (is_array($environmentId) && count($environmentId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environmentId when calling releasesUpdateReleaseEnvironment'
            );
        }
        // verify the required parameter 'apiVersion' is set
        if ($apiVersion === null || (is_array($apiVersion) && count($apiVersion) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiVersion when calling releasesUpdateReleaseEnvironment'
            );
        }

        $resourcePath = '/{organization}/{project}/_apis/Release/releases/{releaseId}/environments/{environmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($apiVersion !== null) {
            $queryParams['api-version'] = ObjectSerializer::toQueryValue($apiVersion);
        }

        // path params
        if ($organization !== null) {
            $resourcePath = str_replace(
                '{' . 'organization' . '}',
                ObjectSerializer::toPathValue($organization),
                $resourcePath
            );
        }
        // path params
        if ($project !== null) {
            $resourcePath = str_replace(
                '{' . 'project' . '}',
                ObjectSerializer::toPathValue($project),
                $resourcePath
            );
        }
        // path params
        if ($releaseId !== null) {
            $resourcePath = str_replace(
                '{' . 'releaseId' . '}',
                ObjectSerializer::toPathValue($releaseId),
                $resourcePath
            );
        }
        // path params
        if ($environmentId !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentId' . '}',
                ObjectSerializer::toPathValue($environmentId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesUpdateReleaseResource
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseUpdateMetadata $body Properties of release to update. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release to update. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FrankHouweling\AzureDevOpsClient\Release\Model\Release
     */
    public function releasesUpdateReleaseResource($organization, $body, $project, $releaseId, $apiVersion)
    {
        list($response) = $this->releasesUpdateReleaseResourceWithHttpInfo($organization, $body, $project, $releaseId, $apiVersion);
        return $response;
    }

    /**
     * Operation releasesUpdateReleaseResourceWithHttpInfo
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseUpdateMetadata $body Properties of release to update. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release to update. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Release\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FrankHouweling\AzureDevOpsClient\Release\Model\Release, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesUpdateReleaseResourceWithHttpInfo($organization, $body, $project, $releaseId, $apiVersion)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Release\Model\Release';
        $request = $this->releasesUpdateReleaseResourceRequest($organization, $body, $project, $releaseId, $apiVersion);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FrankHouweling\AzureDevOpsClient\Release\Model\Release',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesUpdateReleaseResourceAsync
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseUpdateMetadata $body Properties of release to update. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release to update. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesUpdateReleaseResourceAsync($organization, $body, $project, $releaseId, $apiVersion)
    {
        return $this->releasesUpdateReleaseResourceAsyncWithHttpInfo($organization, $body, $project, $releaseId, $apiVersion)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesUpdateReleaseResourceAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseUpdateMetadata $body Properties of release to update. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release to update. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesUpdateReleaseResourceAsyncWithHttpInfo($organization, $body, $project, $releaseId, $apiVersion)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Release\Model\Release';
        $request = $this->releasesUpdateReleaseResourceRequest($organization, $body, $project, $releaseId, $apiVersion);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesUpdateReleaseResource'
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Release\Model\ReleaseUpdateMetadata $body Properties of release to update. (required)
     * @param  string $project Project ID or project name (required)
     * @param  int $releaseId Id of the release to update. (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.8&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesUpdateReleaseResourceRequest($organization, $body, $project, $releaseId, $apiVersion)
    {
        // verify the required parameter 'organization' is set
        if ($organization === null || (is_array($organization) && count($organization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization when calling releasesUpdateReleaseResource'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling releasesUpdateReleaseResource'
            );
        }
        // verify the required parameter 'project' is set
        if ($project === null || (is_array($project) && count($project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project when calling releasesUpdateReleaseResource'
            );
        }
        // verify the required parameter 'releaseId' is set
        if ($releaseId === null || (is_array($releaseId) && count($releaseId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $releaseId when calling releasesUpdateReleaseResource'
            );
        }
        // verify the required parameter 'apiVersion' is set
        if ($apiVersion === null || (is_array($apiVersion) && count($apiVersion) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiVersion when calling releasesUpdateReleaseResource'
            );
        }

        $resourcePath = '/{organization}/{project}/_apis/release/releases/{releaseId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($apiVersion !== null) {
            $queryParams['api-version'] = ObjectSerializer::toQueryValue($apiVersion);
        }

        // path params
        if ($organization !== null) {
            $resourcePath = str_replace(
                '{' . 'organization' . '}',
                ObjectSerializer::toPathValue($organization),
                $resourcePath
            );
        }
        // path params
        if ($project !== null) {
            $resourcePath = str_replace(
                '{' . 'project' . '}',
                ObjectSerializer::toPathValue($project),
                $resourcePath
            );
        }
        // path params
        if ($releaseId !== null) {
            $resourcePath = str_replace(
                '{' . 'releaseId' . '}',
                ObjectSerializer::toPathValue($releaseId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
