<?php
/**
 * WidgetMetadata
 *
 * PHP version 5
 *
 * @category Class
 * @package  FrankHouweling\AzureDevOpsClient\Dashboard
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Dashboard
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0-preview
 * Contact: nugetvss@microsoft.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.11-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace FrankHouweling\AzureDevOpsClient\Dashboard\Model;

use \ArrayAccess;
use \FrankHouweling\AzureDevOpsClient\Dashboard\ObjectSerializer;

/**
 * WidgetMetadata Class Doc Comment
 *
 * @category Class
 * @description Contribution based information describing Dashboard Widgets.
 * @package  FrankHouweling\AzureDevOpsClient\Dashboard
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class WidgetMetadata implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'WidgetMetadata';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'allowedSizes' => '\FrankHouweling\AzureDevOpsClient\Dashboard\Model\WidgetSize[]',
        'analyticsServiceRequired' => 'bool',
        'catalogIconUrl' => 'string',
        'catalogInfoUrl' => 'string',
        'configurationContributionId' => 'string',
        'configurationContributionRelativeId' => 'string',
        'configurationRequired' => 'bool',
        'contentUri' => 'string',
        'contributionId' => 'string',
        'defaultSettings' => 'string',
        'description' => 'string',
        'isEnabled' => 'bool',
        'isNameConfigurable' => 'bool',
        'isVisibleFromCatalog' => 'bool',
        'keywords' => 'string[]',
        'lightboxOptions' => '\FrankHouweling\AzureDevOpsClient\Dashboard\Model\LightboxOptions',
        'loadingImageUrl' => 'string',
        'name' => 'string',
        'publisherName' => 'string',
        'supportedScopes' => 'object[]',
        'tags' => 'string[]',
        'targets' => 'string[]',
        'typeId' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'allowedSizes' => null,
        'analyticsServiceRequired' => null,
        'catalogIconUrl' => null,
        'catalogInfoUrl' => null,
        'configurationContributionId' => null,
        'configurationContributionRelativeId' => null,
        'configurationRequired' => null,
        'contentUri' => null,
        'contributionId' => null,
        'defaultSettings' => null,
        'description' => null,
        'isEnabled' => null,
        'isNameConfigurable' => null,
        'isVisibleFromCatalog' => null,
        'keywords' => null,
        'lightboxOptions' => null,
        'loadingImageUrl' => null,
        'name' => null,
        'publisherName' => null,
        'supportedScopes' => null,
        'tags' => null,
        'targets' => null,
        'typeId' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'allowedSizes' => 'allowedSizes',
        'analyticsServiceRequired' => 'analyticsServiceRequired',
        'catalogIconUrl' => 'catalogIconUrl',
        'catalogInfoUrl' => 'catalogInfoUrl',
        'configurationContributionId' => 'configurationContributionId',
        'configurationContributionRelativeId' => 'configurationContributionRelativeId',
        'configurationRequired' => 'configurationRequired',
        'contentUri' => 'contentUri',
        'contributionId' => 'contributionId',
        'defaultSettings' => 'defaultSettings',
        'description' => 'description',
        'isEnabled' => 'isEnabled',
        'isNameConfigurable' => 'isNameConfigurable',
        'isVisibleFromCatalog' => 'isVisibleFromCatalog',
        'keywords' => 'keywords',
        'lightboxOptions' => 'lightboxOptions',
        'loadingImageUrl' => 'loadingImageUrl',
        'name' => 'name',
        'publisherName' => 'publisherName',
        'supportedScopes' => 'supportedScopes',
        'tags' => 'tags',
        'targets' => 'targets',
        'typeId' => 'typeId'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'allowedSizes' => 'setAllowedSizes',
        'analyticsServiceRequired' => 'setAnalyticsServiceRequired',
        'catalogIconUrl' => 'setCatalogIconUrl',
        'catalogInfoUrl' => 'setCatalogInfoUrl',
        'configurationContributionId' => 'setConfigurationContributionId',
        'configurationContributionRelativeId' => 'setConfigurationContributionRelativeId',
        'configurationRequired' => 'setConfigurationRequired',
        'contentUri' => 'setContentUri',
        'contributionId' => 'setContributionId',
        'defaultSettings' => 'setDefaultSettings',
        'description' => 'setDescription',
        'isEnabled' => 'setIsEnabled',
        'isNameConfigurable' => 'setIsNameConfigurable',
        'isVisibleFromCatalog' => 'setIsVisibleFromCatalog',
        'keywords' => 'setKeywords',
        'lightboxOptions' => 'setLightboxOptions',
        'loadingImageUrl' => 'setLoadingImageUrl',
        'name' => 'setName',
        'publisherName' => 'setPublisherName',
        'supportedScopes' => 'setSupportedScopes',
        'tags' => 'setTags',
        'targets' => 'setTargets',
        'typeId' => 'setTypeId'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'allowedSizes' => 'getAllowedSizes',
        'analyticsServiceRequired' => 'getAnalyticsServiceRequired',
        'catalogIconUrl' => 'getCatalogIconUrl',
        'catalogInfoUrl' => 'getCatalogInfoUrl',
        'configurationContributionId' => 'getConfigurationContributionId',
        'configurationContributionRelativeId' => 'getConfigurationContributionRelativeId',
        'configurationRequired' => 'getConfigurationRequired',
        'contentUri' => 'getContentUri',
        'contributionId' => 'getContributionId',
        'defaultSettings' => 'getDefaultSettings',
        'description' => 'getDescription',
        'isEnabled' => 'getIsEnabled',
        'isNameConfigurable' => 'getIsNameConfigurable',
        'isVisibleFromCatalog' => 'getIsVisibleFromCatalog',
        'keywords' => 'getKeywords',
        'lightboxOptions' => 'getLightboxOptions',
        'loadingImageUrl' => 'getLoadingImageUrl',
        'name' => 'getName',
        'publisherName' => 'getPublisherName',
        'supportedScopes' => 'getSupportedScopes',
        'tags' => 'getTags',
        'targets' => 'getTargets',
        'typeId' => 'getTypeId'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['allowedSizes'] = isset($data['allowedSizes']) ? $data['allowedSizes'] : null;
        $this->container['analyticsServiceRequired'] = isset($data['analyticsServiceRequired']) ? $data['analyticsServiceRequired'] : null;
        $this->container['catalogIconUrl'] = isset($data['catalogIconUrl']) ? $data['catalogIconUrl'] : null;
        $this->container['catalogInfoUrl'] = isset($data['catalogInfoUrl']) ? $data['catalogInfoUrl'] : null;
        $this->container['configurationContributionId'] = isset($data['configurationContributionId']) ? $data['configurationContributionId'] : null;
        $this->container['configurationContributionRelativeId'] = isset($data['configurationContributionRelativeId']) ? $data['configurationContributionRelativeId'] : null;
        $this->container['configurationRequired'] = isset($data['configurationRequired']) ? $data['configurationRequired'] : null;
        $this->container['contentUri'] = isset($data['contentUri']) ? $data['contentUri'] : null;
        $this->container['contributionId'] = isset($data['contributionId']) ? $data['contributionId'] : null;
        $this->container['defaultSettings'] = isset($data['defaultSettings']) ? $data['defaultSettings'] : null;
        $this->container['description'] = isset($data['description']) ? $data['description'] : null;
        $this->container['isEnabled'] = isset($data['isEnabled']) ? $data['isEnabled'] : null;
        $this->container['isNameConfigurable'] = isset($data['isNameConfigurable']) ? $data['isNameConfigurable'] : null;
        $this->container['isVisibleFromCatalog'] = isset($data['isVisibleFromCatalog']) ? $data['isVisibleFromCatalog'] : null;
        $this->container['keywords'] = isset($data['keywords']) ? $data['keywords'] : null;
        $this->container['lightboxOptions'] = isset($data['lightboxOptions']) ? $data['lightboxOptions'] : null;
        $this->container['loadingImageUrl'] = isset($data['loadingImageUrl']) ? $data['loadingImageUrl'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['publisherName'] = isset($data['publisherName']) ? $data['publisherName'] : null;
        $this->container['supportedScopes'] = isset($data['supportedScopes']) ? $data['supportedScopes'] : null;
        $this->container['tags'] = isset($data['tags']) ? $data['tags'] : null;
        $this->container['targets'] = isset($data['targets']) ? $data['targets'] : null;
        $this->container['typeId'] = isset($data['typeId']) ? $data['typeId'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets allowedSizes
     *
     * @return \FrankHouweling\AzureDevOpsClient\Dashboard\Model\WidgetSize[]
     */
    public function getAllowedSizes()
    {
        return $this->container['allowedSizes'];
    }

    /**
     * Sets allowedSizes
     *
     * @param \FrankHouweling\AzureDevOpsClient\Dashboard\Model\WidgetSize[] $allowedSizes Sizes supported by the Widget.
     *
     * @return $this
     */
    public function setAllowedSizes($allowedSizes)
    {
        $this->container['allowedSizes'] = $allowedSizes;

        return $this;
    }

    /**
     * Gets analyticsServiceRequired
     *
     * @return bool
     */
    public function getAnalyticsServiceRequired()
    {
        return $this->container['analyticsServiceRequired'];
    }

    /**
     * Sets analyticsServiceRequired
     *
     * @param bool $analyticsServiceRequired Opt-in boolean that indicates if the widget requires the Analytics Service to function. Widgets requiring the analytics service are hidden from the catalog if the Analytics Service is not available.
     *
     * @return $this
     */
    public function setAnalyticsServiceRequired($analyticsServiceRequired)
    {
        $this->container['analyticsServiceRequired'] = $analyticsServiceRequired;

        return $this;
    }

    /**
     * Gets catalogIconUrl
     *
     * @return string
     */
    public function getCatalogIconUrl()
    {
        return $this->container['catalogIconUrl'];
    }

    /**
     * Sets catalogIconUrl
     *
     * @param string $catalogIconUrl Resource for an icon in the widget catalog.
     *
     * @return $this
     */
    public function setCatalogIconUrl($catalogIconUrl)
    {
        $this->container['catalogIconUrl'] = $catalogIconUrl;

        return $this;
    }

    /**
     * Gets catalogInfoUrl
     *
     * @return string
     */
    public function getCatalogInfoUrl()
    {
        return $this->container['catalogInfoUrl'];
    }

    /**
     * Sets catalogInfoUrl
     *
     * @param string $catalogInfoUrl Opt-in URL string pointing at widget information. Defaults to extension marketplace URL if omitted
     *
     * @return $this
     */
    public function setCatalogInfoUrl($catalogInfoUrl)
    {
        $this->container['catalogInfoUrl'] = $catalogInfoUrl;

        return $this;
    }

    /**
     * Gets configurationContributionId
     *
     * @return string
     */
    public function getConfigurationContributionId()
    {
        return $this->container['configurationContributionId'];
    }

    /**
     * Sets configurationContributionId
     *
     * @param string $configurationContributionId The id of the underlying contribution defining the supplied Widget custom configuration UI. Null if custom configuration UI is not available.
     *
     * @return $this
     */
    public function setConfigurationContributionId($configurationContributionId)
    {
        $this->container['configurationContributionId'] = $configurationContributionId;

        return $this;
    }

    /**
     * Gets configurationContributionRelativeId
     *
     * @return string
     */
    public function getConfigurationContributionRelativeId()
    {
        return $this->container['configurationContributionRelativeId'];
    }

    /**
     * Sets configurationContributionRelativeId
     *
     * @param string $configurationContributionRelativeId The relative id of the underlying contribution defining the supplied Widget custom configuration UI. Null if custom configuration UI is not available.
     *
     * @return $this
     */
    public function setConfigurationContributionRelativeId($configurationContributionRelativeId)
    {
        $this->container['configurationContributionRelativeId'] = $configurationContributionRelativeId;

        return $this;
    }

    /**
     * Gets configurationRequired
     *
     * @return bool
     */
    public function getConfigurationRequired()
    {
        return $this->container['configurationRequired'];
    }

    /**
     * Sets configurationRequired
     *
     * @param bool $configurationRequired Indicates if the widget requires configuration before being added to dashboard.
     *
     * @return $this
     */
    public function setConfigurationRequired($configurationRequired)
    {
        $this->container['configurationRequired'] = $configurationRequired;

        return $this;
    }

    /**
     * Gets contentUri
     *
     * @return string
     */
    public function getContentUri()
    {
        return $this->container['contentUri'];
    }

    /**
     * Sets contentUri
     *
     * @param string $contentUri Uri for the widget content to be loaded from .
     *
     * @return $this
     */
    public function setContentUri($contentUri)
    {
        $this->container['contentUri'] = $contentUri;

        return $this;
    }

    /**
     * Gets contributionId
     *
     * @return string
     */
    public function getContributionId()
    {
        return $this->container['contributionId'];
    }

    /**
     * Sets contributionId
     *
     * @param string $contributionId The id of the underlying contribution defining the supplied Widget.
     *
     * @return $this
     */
    public function setContributionId($contributionId)
    {
        $this->container['contributionId'] = $contributionId;

        return $this;
    }

    /**
     * Gets defaultSettings
     *
     * @return string
     */
    public function getDefaultSettings()
    {
        return $this->container['defaultSettings'];
    }

    /**
     * Sets defaultSettings
     *
     * @param string $defaultSettings Optional default settings to be copied into widget settings.
     *
     * @return $this
     */
    public function setDefaultSettings($defaultSettings)
    {
        $this->container['defaultSettings'] = $defaultSettings;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string $description Summary information describing the widget.
     *
     * @return $this
     */
    public function setDescription($description)
    {
        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets isEnabled
     *
     * @return bool
     */
    public function getIsEnabled()
    {
        return $this->container['isEnabled'];
    }

    /**
     * Sets isEnabled
     *
     * @param bool $isEnabled Widgets can be disabled by the app store.  We'll need to gracefully handle for: - persistence (Allow) - Requests (Tag as disabled, and provide context)
     *
     * @return $this
     */
    public function setIsEnabled($isEnabled)
    {
        $this->container['isEnabled'] = $isEnabled;

        return $this;
    }

    /**
     * Gets isNameConfigurable
     *
     * @return bool
     */
    public function getIsNameConfigurable()
    {
        return $this->container['isNameConfigurable'];
    }

    /**
     * Sets isNameConfigurable
     *
     * @param bool $isNameConfigurable Opt-out boolean that indicates if the widget supports widget name/title configuration. Widgets ignoring the name should set it to false in the manifest.
     *
     * @return $this
     */
    public function setIsNameConfigurable($isNameConfigurable)
    {
        $this->container['isNameConfigurable'] = $isNameConfigurable;

        return $this;
    }

    /**
     * Gets isVisibleFromCatalog
     *
     * @return bool
     */
    public function getIsVisibleFromCatalog()
    {
        return $this->container['isVisibleFromCatalog'];
    }

    /**
     * Sets isVisibleFromCatalog
     *
     * @param bool $isVisibleFromCatalog Opt-out boolean indicating if the widget is hidden from the catalog. Commonly, this is used to allow developers to disable creation of a deprecated widget. A widget must have a functional default state, or have a configuration experience, in order to be visible from the catalog.
     *
     * @return $this
     */
    public function setIsVisibleFromCatalog($isVisibleFromCatalog)
    {
        $this->container['isVisibleFromCatalog'] = $isVisibleFromCatalog;

        return $this;
    }

    /**
     * Gets keywords
     *
     * @return string[]
     */
    public function getKeywords()
    {
        return $this->container['keywords'];
    }

    /**
     * Sets keywords
     *
     * @param string[] $keywords Keywords associated with this widget, non-filterable and invisible
     *
     * @return $this
     */
    public function setKeywords($keywords)
    {
        $this->container['keywords'] = $keywords;

        return $this;
    }

    /**
     * Gets lightboxOptions
     *
     * @return \FrankHouweling\AzureDevOpsClient\Dashboard\Model\LightboxOptions
     */
    public function getLightboxOptions()
    {
        return $this->container['lightboxOptions'];
    }

    /**
     * Sets lightboxOptions
     *
     * @param \FrankHouweling\AzureDevOpsClient\Dashboard\Model\LightboxOptions $lightboxOptions Opt-in properties for customizing widget presentation in a \"lightbox\" dialog.
     *
     * @return $this
     */
    public function setLightboxOptions($lightboxOptions)
    {
        $this->container['lightboxOptions'] = $lightboxOptions;

        return $this;
    }

    /**
     * Gets loadingImageUrl
     *
     * @return string
     */
    public function getLoadingImageUrl()
    {
        return $this->container['loadingImageUrl'];
    }

    /**
     * Sets loadingImageUrl
     *
     * @param string $loadingImageUrl Resource for a loading placeholder image on dashboard
     *
     * @return $this
     */
    public function setLoadingImageUrl($loadingImageUrl)
    {
        $this->container['loadingImageUrl'] = $loadingImageUrl;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name User facing name of the widget type. Each widget must use a unique value here.
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets publisherName
     *
     * @return string
     */
    public function getPublisherName()
    {
        return $this->container['publisherName'];
    }

    /**
     * Sets publisherName
     *
     * @param string $publisherName Publisher Name of this kind of widget.
     *
     * @return $this
     */
    public function setPublisherName($publisherName)
    {
        $this->container['publisherName'] = $publisherName;

        return $this;
    }

    /**
     * Gets supportedScopes
     *
     * @return object[]
     */
    public function getSupportedScopes()
    {
        return $this->container['supportedScopes'];
    }

    /**
     * Sets supportedScopes
     *
     * @param object[] $supportedScopes Data contract required for the widget to function and to work in its container.
     *
     * @return $this
     */
    public function setSupportedScopes($supportedScopes)
    {
        $this->container['supportedScopes'] = $supportedScopes;

        return $this;
    }

    /**
     * Gets tags
     *
     * @return string[]
     */
    public function getTags()
    {
        return $this->container['tags'];
    }

    /**
     * Sets tags
     *
     * @param string[] $tags Tags associated with this widget, visible on each widget and filterable.
     *
     * @return $this
     */
    public function setTags($tags)
    {
        $this->container['tags'] = $tags;

        return $this;
    }

    /**
     * Gets targets
     *
     * @return string[]
     */
    public function getTargets()
    {
        return $this->container['targets'];
    }

    /**
     * Sets targets
     *
     * @param string[] $targets Contribution target IDs
     *
     * @return $this
     */
    public function setTargets($targets)
    {
        $this->container['targets'] = $targets;

        return $this;
    }

    /**
     * Gets typeId
     *
     * @return string
     */
    public function getTypeId()
    {
        return $this->container['typeId'];
    }

    /**
     * Sets typeId
     *
     * @param string $typeId Deprecated: locally unique developer-facing id of this kind of widget. ContributionId provides a globally unique identifier for widget types.
     *
     * @return $this
     */
    public function setTypeId($typeId)
    {
        $this->container['typeId'] = $typeId;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


