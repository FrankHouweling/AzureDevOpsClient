<?php
/**
 * GitPullRequestCompletionOptions
 *
 * PHP version 5
 *
 * @category Class
 * @package  FrankHouweling\AzureDevOpsClient\Git
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Git
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0-preview
 * Contact: nugetvss@microsoft.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.11-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace FrankHouweling\AzureDevOpsClient\Git\Model;

use \ArrayAccess;
use \FrankHouweling\AzureDevOpsClient\Git\ObjectSerializer;

/**
 * GitPullRequestCompletionOptions Class Doc Comment
 *
 * @category Class
 * @description Preferences about how the pull request should be completed.
 * @package  FrankHouweling\AzureDevOpsClient\Git
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class GitPullRequestCompletionOptions implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'GitPullRequestCompletionOptions';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'bypassPolicy' => 'bool',
        'bypassReason' => 'string',
        'deleteSourceBranch' => 'bool',
        'mergeCommitMessage' => 'string',
        'mergeStrategy' => 'string',
        'squashMerge' => 'bool',
        'transitionWorkItems' => 'bool',
        'triggeredByAutoComplete' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'bypassPolicy' => null,
        'bypassReason' => null,
        'deleteSourceBranch' => null,
        'mergeCommitMessage' => null,
        'mergeStrategy' => null,
        'squashMerge' => null,
        'transitionWorkItems' => null,
        'triggeredByAutoComplete' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'bypassPolicy' => 'bypassPolicy',
        'bypassReason' => 'bypassReason',
        'deleteSourceBranch' => 'deleteSourceBranch',
        'mergeCommitMessage' => 'mergeCommitMessage',
        'mergeStrategy' => 'mergeStrategy',
        'squashMerge' => 'squashMerge',
        'transitionWorkItems' => 'transitionWorkItems',
        'triggeredByAutoComplete' => 'triggeredByAutoComplete'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'bypassPolicy' => 'setBypassPolicy',
        'bypassReason' => 'setBypassReason',
        'deleteSourceBranch' => 'setDeleteSourceBranch',
        'mergeCommitMessage' => 'setMergeCommitMessage',
        'mergeStrategy' => 'setMergeStrategy',
        'squashMerge' => 'setSquashMerge',
        'transitionWorkItems' => 'setTransitionWorkItems',
        'triggeredByAutoComplete' => 'setTriggeredByAutoComplete'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'bypassPolicy' => 'getBypassPolicy',
        'bypassReason' => 'getBypassReason',
        'deleteSourceBranch' => 'getDeleteSourceBranch',
        'mergeCommitMessage' => 'getMergeCommitMessage',
        'mergeStrategy' => 'getMergeStrategy',
        'squashMerge' => 'getSquashMerge',
        'transitionWorkItems' => 'getTransitionWorkItems',
        'triggeredByAutoComplete' => 'getTriggeredByAutoComplete'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const MERGE_STRATEGY_NO_FAST_FORWARD = 'noFastForward';
    const MERGE_STRATEGY_SQUASH = 'squash';
    const MERGE_STRATEGY_REBASE = 'rebase';
    const MERGE_STRATEGY_REBASE_MERGE = 'rebaseMerge';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getMergeStrategyAllowableValues()
    {
        return [
            self::MERGE_STRATEGY_NO_FAST_FORWARD,
            self::MERGE_STRATEGY_SQUASH,
            self::MERGE_STRATEGY_REBASE,
            self::MERGE_STRATEGY_REBASE_MERGE,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['bypassPolicy'] = isset($data['bypassPolicy']) ? $data['bypassPolicy'] : null;
        $this->container['bypassReason'] = isset($data['bypassReason']) ? $data['bypassReason'] : null;
        $this->container['deleteSourceBranch'] = isset($data['deleteSourceBranch']) ? $data['deleteSourceBranch'] : null;
        $this->container['mergeCommitMessage'] = isset($data['mergeCommitMessage']) ? $data['mergeCommitMessage'] : null;
        $this->container['mergeStrategy'] = isset($data['mergeStrategy']) ? $data['mergeStrategy'] : null;
        $this->container['squashMerge'] = isset($data['squashMerge']) ? $data['squashMerge'] : null;
        $this->container['transitionWorkItems'] = isset($data['transitionWorkItems']) ? $data['transitionWorkItems'] : null;
        $this->container['triggeredByAutoComplete'] = isset($data['triggeredByAutoComplete']) ? $data['triggeredByAutoComplete'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getMergeStrategyAllowableValues();
        if (!is_null($this->container['mergeStrategy']) && !in_array($this->container['mergeStrategy'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'mergeStrategy', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets bypassPolicy
     *
     * @return bool
     */
    public function getBypassPolicy()
    {
        return $this->container['bypassPolicy'];
    }

    /**
     * Sets bypassPolicy
     *
     * @param bool $bypassPolicy If true, policies will be explicitly bypassed while the pull request is completed.
     *
     * @return $this
     */
    public function setBypassPolicy($bypassPolicy)
    {
        $this->container['bypassPolicy'] = $bypassPolicy;

        return $this;
    }

    /**
     * Gets bypassReason
     *
     * @return string
     */
    public function getBypassReason()
    {
        return $this->container['bypassReason'];
    }

    /**
     * Sets bypassReason
     *
     * @param string $bypassReason If policies are bypassed, this reason is stored as to why bypass was used.
     *
     * @return $this
     */
    public function setBypassReason($bypassReason)
    {
        $this->container['bypassReason'] = $bypassReason;

        return $this;
    }

    /**
     * Gets deleteSourceBranch
     *
     * @return bool
     */
    public function getDeleteSourceBranch()
    {
        return $this->container['deleteSourceBranch'];
    }

    /**
     * Sets deleteSourceBranch
     *
     * @param bool $deleteSourceBranch If true, the source branch of the pull request will be deleted after completion.
     *
     * @return $this
     */
    public function setDeleteSourceBranch($deleteSourceBranch)
    {
        $this->container['deleteSourceBranch'] = $deleteSourceBranch;

        return $this;
    }

    /**
     * Gets mergeCommitMessage
     *
     * @return string
     */
    public function getMergeCommitMessage()
    {
        return $this->container['mergeCommitMessage'];
    }

    /**
     * Sets mergeCommitMessage
     *
     * @param string $mergeCommitMessage If set, this will be used as the commit message of the merge commit.
     *
     * @return $this
     */
    public function setMergeCommitMessage($mergeCommitMessage)
    {
        $this->container['mergeCommitMessage'] = $mergeCommitMessage;

        return $this;
    }

    /**
     * Gets mergeStrategy
     *
     * @return string
     */
    public function getMergeStrategy()
    {
        return $this->container['mergeStrategy'];
    }

    /**
     * Sets mergeStrategy
     *
     * @param string $mergeStrategy Specify the strategy used to merge the pull request during completion. If MergeStrategy is not set to any value, a no-FF merge will be created if SquashMerge == false. If MergeStrategy is not set to any value, the pull request commits will be squash if SquashMerge == true. The SquashMerge member is deprecated. It is recommended that you explicitly set MergeStrategy in all cases. If an explicit value is provided for MergeStrategy, the SquashMerge member will be ignored.
     *
     * @return $this
     */
    public function setMergeStrategy($mergeStrategy)
    {
        $allowedValues = $this->getMergeStrategyAllowableValues();
        if (!is_null($mergeStrategy) && !in_array($mergeStrategy, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'mergeStrategy', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['mergeStrategy'] = $mergeStrategy;

        return $this;
    }

    /**
     * Gets squashMerge
     *
     * @return bool
     */
    public function getSquashMerge()
    {
        return $this->container['squashMerge'];
    }

    /**
     * Sets squashMerge
     *
     * @param bool $squashMerge SquashMerge is deprecated. You should explicitly set the value of MergeStrategy. If MergeStrategy is set to any value, the SquashMerge value will be ignored. If MergeStrategy is not set, the merge strategy will be no-fast-forward if this flag is false, or squash if true.
     *
     * @return $this
     */
    public function setSquashMerge($squashMerge)
    {
        $this->container['squashMerge'] = $squashMerge;

        return $this;
    }

    /**
     * Gets transitionWorkItems
     *
     * @return bool
     */
    public function getTransitionWorkItems()
    {
        return $this->container['transitionWorkItems'];
    }

    /**
     * Sets transitionWorkItems
     *
     * @param bool $transitionWorkItems If true, we will attempt to transition any work items linked to the pull request into the next logical state (i.e. Active -> Resolved)
     *
     * @return $this
     */
    public function setTransitionWorkItems($transitionWorkItems)
    {
        $this->container['transitionWorkItems'] = $transitionWorkItems;

        return $this;
    }

    /**
     * Gets triggeredByAutoComplete
     *
     * @return bool
     */
    public function getTriggeredByAutoComplete()
    {
        return $this->container['triggeredByAutoComplete'];
    }

    /**
     * Sets triggeredByAutoComplete
     *
     * @param bool $triggeredByAutoComplete If true, the current completion attempt was triggered via auto-complete. Used internally.
     *
     * @return $this
     */
    public function setTriggeredByAutoComplete($triggeredByAutoComplete)
    {
        $this->container['triggeredByAutoComplete'] = $triggeredByAutoComplete;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


