<?php
/**
 * GitPullRequest
 *
 * PHP version 5
 *
 * @category Class
 * @package  AzureDevOpsClient\Git
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Git
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0-preview
 * Contact: nugetvss@microsoft.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.11-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model;

use \ArrayAccess;
use \AzureDevOpsClient\Git\ObjectSerializer;

/**
 * GitPullRequest Class Doc Comment
 *
 * @category Class
 * @description Represents all the data associated with a pull request.
 * @package  AzureDevOpsClient\Git
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class GitPullRequest implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'GitPullRequest';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'links' => '\AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\ReferenceLinks',
        'artifactId' => 'string',
        'autoCompleteSetBy' => '\AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\IdentityRef',
        'closedBy' => '\AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\IdentityRef',
        'closedDate' => '\DateTime',
        'codeReviewId' => 'int',
        'commits' => '\AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitCommitRef[]',
        'completionOptions' => '\AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitPullRequestCompletionOptions',
        'completionQueueTime' => '\DateTime',
        'createdBy' => '\AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\IdentityRef',
        'creationDate' => '\DateTime',
        'description' => 'string',
        'forkSource' => '\AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitForkRef',
        'isDraft' => 'bool',
        'labels' => '\AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\WebApiTagDefinition[]',
        'lastMergeCommit' => '\AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitCommitRef',
        'lastMergeSourceCommit' => '\AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitCommitRef',
        'lastMergeTargetCommit' => '\AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitCommitRef',
        'mergeFailureMessage' => 'string',
        'mergeFailureType' => 'string',
        'mergeId' => 'string',
        'mergeOptions' => '\AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitPullRequestMergeOptions',
        'mergeStatus' => 'string',
        'pullRequestId' => 'int',
        'remoteUrl' => 'string',
        'repository' => '\AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitRepository',
        'reviewers' => '\AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\IdentityRefWithVote[]',
        'sourceRefName' => 'string',
        'status' => 'string',
        'supportsIterations' => 'bool',
        'targetRefName' => 'string',
        'title' => 'string',
        'url' => 'string',
        'workItemRefs' => '\AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\ResourceRef[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'links' => null,
        'artifactId' => null,
        'autoCompleteSetBy' => null,
        'closedBy' => null,
        'closedDate' => 'date-time',
        'codeReviewId' => 'int32',
        'commits' => null,
        'completionOptions' => null,
        'completionQueueTime' => 'date-time',
        'createdBy' => null,
        'creationDate' => 'date-time',
        'description' => null,
        'forkSource' => null,
        'isDraft' => null,
        'labels' => null,
        'lastMergeCommit' => null,
        'lastMergeSourceCommit' => null,
        'lastMergeTargetCommit' => null,
        'mergeFailureMessage' => null,
        'mergeFailureType' => null,
        'mergeId' => 'uuid',
        'mergeOptions' => null,
        'mergeStatus' => null,
        'pullRequestId' => 'int32',
        'remoteUrl' => null,
        'repository' => null,
        'reviewers' => null,
        'sourceRefName' => null,
        'status' => null,
        'supportsIterations' => null,
        'targetRefName' => null,
        'title' => null,
        'url' => null,
        'workItemRefs' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'links' => '_links',
        'artifactId' => 'artifactId',
        'autoCompleteSetBy' => 'autoCompleteSetBy',
        'closedBy' => 'closedBy',
        'closedDate' => 'closedDate',
        'codeReviewId' => 'codeReviewId',
        'commits' => 'commits',
        'completionOptions' => 'completionOptions',
        'completionQueueTime' => 'completionQueueTime',
        'createdBy' => 'createdBy',
        'creationDate' => 'creationDate',
        'description' => 'description',
        'forkSource' => 'forkSource',
        'isDraft' => 'isDraft',
        'labels' => 'labels',
        'lastMergeCommit' => 'lastMergeCommit',
        'lastMergeSourceCommit' => 'lastMergeSourceCommit',
        'lastMergeTargetCommit' => 'lastMergeTargetCommit',
        'mergeFailureMessage' => 'mergeFailureMessage',
        'mergeFailureType' => 'mergeFailureType',
        'mergeId' => 'mergeId',
        'mergeOptions' => 'mergeOptions',
        'mergeStatus' => 'mergeStatus',
        'pullRequestId' => 'pullRequestId',
        'remoteUrl' => 'remoteUrl',
        'repository' => 'repository',
        'reviewers' => 'reviewers',
        'sourceRefName' => 'sourceRefName',
        'status' => 'status',
        'supportsIterations' => 'supportsIterations',
        'targetRefName' => 'targetRefName',
        'title' => 'title',
        'url' => 'url',
        'workItemRefs' => 'workItemRefs'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'links' => 'setLinks',
        'artifactId' => 'setArtifactId',
        'autoCompleteSetBy' => 'setAutoCompleteSetBy',
        'closedBy' => 'setClosedBy',
        'closedDate' => 'setClosedDate',
        'codeReviewId' => 'setCodeReviewId',
        'commits' => 'setCommits',
        'completionOptions' => 'setCompletionOptions',
        'completionQueueTime' => 'setCompletionQueueTime',
        'createdBy' => 'setCreatedBy',
        'creationDate' => 'setCreationDate',
        'description' => 'setDescription',
        'forkSource' => 'setForkSource',
        'isDraft' => 'setIsDraft',
        'labels' => 'setLabels',
        'lastMergeCommit' => 'setLastMergeCommit',
        'lastMergeSourceCommit' => 'setLastMergeSourceCommit',
        'lastMergeTargetCommit' => 'setLastMergeTargetCommit',
        'mergeFailureMessage' => 'setMergeFailureMessage',
        'mergeFailureType' => 'setMergeFailureType',
        'mergeId' => 'setMergeId',
        'mergeOptions' => 'setMergeOptions',
        'mergeStatus' => 'setMergeStatus',
        'pullRequestId' => 'setPullRequestId',
        'remoteUrl' => 'setRemoteUrl',
        'repository' => 'setRepository',
        'reviewers' => 'setReviewers',
        'sourceRefName' => 'setSourceRefName',
        'status' => 'setStatus',
        'supportsIterations' => 'setSupportsIterations',
        'targetRefName' => 'setTargetRefName',
        'title' => 'setTitle',
        'url' => 'setUrl',
        'workItemRefs' => 'setWorkItemRefs'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'links' => 'getLinks',
        'artifactId' => 'getArtifactId',
        'autoCompleteSetBy' => 'getAutoCompleteSetBy',
        'closedBy' => 'getClosedBy',
        'closedDate' => 'getClosedDate',
        'codeReviewId' => 'getCodeReviewId',
        'commits' => 'getCommits',
        'completionOptions' => 'getCompletionOptions',
        'completionQueueTime' => 'getCompletionQueueTime',
        'createdBy' => 'getCreatedBy',
        'creationDate' => 'getCreationDate',
        'description' => 'getDescription',
        'forkSource' => 'getForkSource',
        'isDraft' => 'getIsDraft',
        'labels' => 'getLabels',
        'lastMergeCommit' => 'getLastMergeCommit',
        'lastMergeSourceCommit' => 'getLastMergeSourceCommit',
        'lastMergeTargetCommit' => 'getLastMergeTargetCommit',
        'mergeFailureMessage' => 'getMergeFailureMessage',
        'mergeFailureType' => 'getMergeFailureType',
        'mergeId' => 'getMergeId',
        'mergeOptions' => 'getMergeOptions',
        'mergeStatus' => 'getMergeStatus',
        'pullRequestId' => 'getPullRequestId',
        'remoteUrl' => 'getRemoteUrl',
        'repository' => 'getRepository',
        'reviewers' => 'getReviewers',
        'sourceRefName' => 'getSourceRefName',
        'status' => 'getStatus',
        'supportsIterations' => 'getSupportsIterations',
        'targetRefName' => 'getTargetRefName',
        'title' => 'getTitle',
        'url' => 'getUrl',
        'workItemRefs' => 'getWorkItemRefs'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const MERGE_FAILURE_TYPE_NONE = 'none';
    const MERGE_FAILURE_TYPE_UNKNOWN = 'unknown';
    const MERGE_FAILURE_TYPE_CASE_SENSITIVE = 'caseSensitive';
    const MERGE_FAILURE_TYPE_OBJECT_TOO_LARGE = 'objectTooLarge';
    const MERGE_STATUS_NOT_SET = 'notSet';
    const MERGE_STATUS_QUEUED = 'queued';
    const MERGE_STATUS_CONFLICTS = 'conflicts';
    const MERGE_STATUS_SUCCEEDED = 'succeeded';
    const MERGE_STATUS_REJECTED_BY_POLICY = 'rejectedByPolicy';
    const MERGE_STATUS_FAILURE = 'failure';
    const STATUS_NOT_SET = 'notSet';
    const STATUS_ACTIVE = 'active';
    const STATUS_ABANDONED = 'abandoned';
    const STATUS_COMPLETED = 'completed';
    const STATUS_ALL = 'all';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getMergeFailureTypeAllowableValues()
    {
        return [
            self::MERGE_FAILURE_TYPE_NONE,
            self::MERGE_FAILURE_TYPE_UNKNOWN,
            self::MERGE_FAILURE_TYPE_CASE_SENSITIVE,
            self::MERGE_FAILURE_TYPE_OBJECT_TOO_LARGE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getMergeStatusAllowableValues()
    {
        return [
            self::MERGE_STATUS_NOT_SET,
            self::MERGE_STATUS_QUEUED,
            self::MERGE_STATUS_CONFLICTS,
            self::MERGE_STATUS_SUCCEEDED,
            self::MERGE_STATUS_REJECTED_BY_POLICY,
            self::MERGE_STATUS_FAILURE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_NOT_SET,
            self::STATUS_ACTIVE,
            self::STATUS_ABANDONED,
            self::STATUS_COMPLETED,
            self::STATUS_ALL,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['links'] = isset($data['links']) ? $data['links'] : null;
        $this->container['artifactId'] = isset($data['artifactId']) ? $data['artifactId'] : null;
        $this->container['autoCompleteSetBy'] = isset($data['autoCompleteSetBy']) ? $data['autoCompleteSetBy'] : null;
        $this->container['closedBy'] = isset($data['closedBy']) ? $data['closedBy'] : null;
        $this->container['closedDate'] = isset($data['closedDate']) ? $data['closedDate'] : null;
        $this->container['codeReviewId'] = isset($data['codeReviewId']) ? $data['codeReviewId'] : null;
        $this->container['commits'] = isset($data['commits']) ? $data['commits'] : null;
        $this->container['completionOptions'] = isset($data['completionOptions']) ? $data['completionOptions'] : null;
        $this->container['completionQueueTime'] = isset($data['completionQueueTime']) ? $data['completionQueueTime'] : null;
        $this->container['createdBy'] = isset($data['createdBy']) ? $data['createdBy'] : null;
        $this->container['creationDate'] = isset($data['creationDate']) ? $data['creationDate'] : null;
        $this->container['description'] = isset($data['description']) ? $data['description'] : null;
        $this->container['forkSource'] = isset($data['forkSource']) ? $data['forkSource'] : null;
        $this->container['isDraft'] = isset($data['isDraft']) ? $data['isDraft'] : null;
        $this->container['labels'] = isset($data['labels']) ? $data['labels'] : null;
        $this->container['lastMergeCommit'] = isset($data['lastMergeCommit']) ? $data['lastMergeCommit'] : null;
        $this->container['lastMergeSourceCommit'] = isset($data['lastMergeSourceCommit']) ? $data['lastMergeSourceCommit'] : null;
        $this->container['lastMergeTargetCommit'] = isset($data['lastMergeTargetCommit']) ? $data['lastMergeTargetCommit'] : null;
        $this->container['mergeFailureMessage'] = isset($data['mergeFailureMessage']) ? $data['mergeFailureMessage'] : null;
        $this->container['mergeFailureType'] = isset($data['mergeFailureType']) ? $data['mergeFailureType'] : null;
        $this->container['mergeId'] = isset($data['mergeId']) ? $data['mergeId'] : null;
        $this->container['mergeOptions'] = isset($data['mergeOptions']) ? $data['mergeOptions'] : null;
        $this->container['mergeStatus'] = isset($data['mergeStatus']) ? $data['mergeStatus'] : null;
        $this->container['pullRequestId'] = isset($data['pullRequestId']) ? $data['pullRequestId'] : null;
        $this->container['remoteUrl'] = isset($data['remoteUrl']) ? $data['remoteUrl'] : null;
        $this->container['repository'] = isset($data['repository']) ? $data['repository'] : null;
        $this->container['reviewers'] = isset($data['reviewers']) ? $data['reviewers'] : null;
        $this->container['sourceRefName'] = isset($data['sourceRefName']) ? $data['sourceRefName'] : null;
        $this->container['status'] = isset($data['status']) ? $data['status'] : null;
        $this->container['supportsIterations'] = isset($data['supportsIterations']) ? $data['supportsIterations'] : null;
        $this->container['targetRefName'] = isset($data['targetRefName']) ? $data['targetRefName'] : null;
        $this->container['title'] = isset($data['title']) ? $data['title'] : null;
        $this->container['url'] = isset($data['url']) ? $data['url'] : null;
        $this->container['workItemRefs'] = isset($data['workItemRefs']) ? $data['workItemRefs'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getMergeFailureTypeAllowableValues();
        if (!is_null($this->container['mergeFailureType']) && !in_array($this->container['mergeFailureType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'mergeFailureType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getMergeStatusAllowableValues();
        if (!is_null($this->container['mergeStatus']) && !in_array($this->container['mergeStatus'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'mergeStatus', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'status', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets links
     *
     * @return \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\ReferenceLinks
     */
    public function getLinks()
    {
        return $this->container['links'];
    }

    /**
     * Sets links
     *
     * @param \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\ReferenceLinks $links Links to other related objects.
     *
     * @return $this
     */
    public function setLinks($links)
    {
        $this->container['links'] = $links;

        return $this;
    }

    /**
     * Gets artifactId
     *
     * @return string
     */
    public function getArtifactId()
    {
        return $this->container['artifactId'];
    }

    /**
     * Sets artifactId
     *
     * @param string $artifactId A string which uniquely identifies this pull request. To generate an artifact ID for a pull request, use this template: ```vstfs:///Git/PullRequestId/{projectId}/{repositoryId}/{pullRequestId}```
     *
     * @return $this
     */
    public function setArtifactId($artifactId)
    {
        $this->container['artifactId'] = $artifactId;

        return $this;
    }

    /**
     * Gets autoCompleteSetBy
     *
     * @return \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\IdentityRef
     */
    public function getAutoCompleteSetBy()
    {
        return $this->container['autoCompleteSetBy'];
    }

    /**
     * Sets autoCompleteSetBy
     *
     * @param \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\IdentityRef $autoCompleteSetBy If set, auto-complete is enabled for this pull request and this is the identity that enabled it.
     *
     * @return $this
     */
    public function setAutoCompleteSetBy($autoCompleteSetBy)
    {
        $this->container['autoCompleteSetBy'] = $autoCompleteSetBy;

        return $this;
    }

    /**
     * Gets closedBy
     *
     * @return \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\IdentityRef
     */
    public function getClosedBy()
    {
        return $this->container['closedBy'];
    }

    /**
     * Sets closedBy
     *
     * @param \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\IdentityRef $closedBy The user who closed the pull request.
     *
     * @return $this
     */
    public function setClosedBy($closedBy)
    {
        $this->container['closedBy'] = $closedBy;

        return $this;
    }

    /**
     * Gets closedDate
     *
     * @return \DateTime
     */
    public function getClosedDate()
    {
        return $this->container['closedDate'];
    }

    /**
     * Sets closedDate
     *
     * @param \DateTime $closedDate The date when the pull request was closed (completed, abandoned, or merged externally).
     *
     * @return $this
     */
    public function setClosedDate($closedDate)
    {
        $this->container['closedDate'] = $closedDate;

        return $this;
    }

    /**
     * Gets codeReviewId
     *
     * @return int
     */
    public function getCodeReviewId()
    {
        return $this->container['codeReviewId'];
    }

    /**
     * Sets codeReviewId
     *
     * @param int $codeReviewId The code review ID of the pull request. Used internally.
     *
     * @return $this
     */
    public function setCodeReviewId($codeReviewId)
    {
        $this->container['codeReviewId'] = $codeReviewId;

        return $this;
    }

    /**
     * Gets commits
     *
     * @return \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitCommitRef[]
     */
    public function getCommits()
    {
        return $this->container['commits'];
    }

    /**
     * Sets commits
     *
     * @param \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitCommitRef[] $commits The commits contained in the pull request.
     *
     * @return $this
     */
    public function setCommits($commits)
    {
        $this->container['commits'] = $commits;

        return $this;
    }

    /**
     * Gets completionOptions
     *
     * @return \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitPullRequestCompletionOptions
     */
    public function getCompletionOptions()
    {
        return $this->container['completionOptions'];
    }

    /**
     * Sets completionOptions
     *
     * @param \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitPullRequestCompletionOptions $completionOptions Options which affect how the pull request will be merged when it is completed.
     *
     * @return $this
     */
    public function setCompletionOptions($completionOptions)
    {
        $this->container['completionOptions'] = $completionOptions;

        return $this;
    }

    /**
     * Gets completionQueueTime
     *
     * @return \DateTime
     */
    public function getCompletionQueueTime()
    {
        return $this->container['completionQueueTime'];
    }

    /**
     * Sets completionQueueTime
     *
     * @param \DateTime $completionQueueTime The most recent date at which the pull request entered the queue to be completed. Used internally.
     *
     * @return $this
     */
    public function setCompletionQueueTime($completionQueueTime)
    {
        $this->container['completionQueueTime'] = $completionQueueTime;

        return $this;
    }

    /**
     * Gets createdBy
     *
     * @return \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\IdentityRef
     */
    public function getCreatedBy()
    {
        return $this->container['createdBy'];
    }

    /**
     * Sets createdBy
     *
     * @param \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\IdentityRef $createdBy The identity of the user who created the pull request.
     *
     * @return $this
     */
    public function setCreatedBy($createdBy)
    {
        $this->container['createdBy'] = $createdBy;

        return $this;
    }

    /**
     * Gets creationDate
     *
     * @return \DateTime
     */
    public function getCreationDate()
    {
        return $this->container['creationDate'];
    }

    /**
     * Sets creationDate
     *
     * @param \DateTime $creationDate The date when the pull request was created.
     *
     * @return $this
     */
    public function setCreationDate($creationDate)
    {
        $this->container['creationDate'] = $creationDate;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string $description The description of the pull request.
     *
     * @return $this
     */
    public function setDescription($description)
    {
        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets forkSource
     *
     * @return \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitForkRef
     */
    public function getForkSource()
    {
        return $this->container['forkSource'];
    }

    /**
     * Sets forkSource
     *
     * @param \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitForkRef $forkSource If this is a PR from a fork this will contain information about its source.
     *
     * @return $this
     */
    public function setForkSource($forkSource)
    {
        $this->container['forkSource'] = $forkSource;

        return $this;
    }

    /**
     * Gets isDraft
     *
     * @return bool
     */
    public function getIsDraft()
    {
        return $this->container['isDraft'];
    }

    /**
     * Sets isDraft
     *
     * @param bool $isDraft Draft / WIP pull request.
     *
     * @return $this
     */
    public function setIsDraft($isDraft)
    {
        $this->container['isDraft'] = $isDraft;

        return $this;
    }

    /**
     * Gets labels
     *
     * @return \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\WebApiTagDefinition[]
     */
    public function getLabels()
    {
        return $this->container['labels'];
    }

    /**
     * Sets labels
     *
     * @param \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\WebApiTagDefinition[] $labels The labels associated with the pull request.
     *
     * @return $this
     */
    public function setLabels($labels)
    {
        $this->container['labels'] = $labels;

        return $this;
    }

    /**
     * Gets lastMergeCommit
     *
     * @return \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitCommitRef
     */
    public function getLastMergeCommit()
    {
        return $this->container['lastMergeCommit'];
    }

    /**
     * Sets lastMergeCommit
     *
     * @param \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitCommitRef $lastMergeCommit The commit of the most recent pull request merge. If empty, the most recent merge is in progress or was unsuccessful.
     *
     * @return $this
     */
    public function setLastMergeCommit($lastMergeCommit)
    {
        $this->container['lastMergeCommit'] = $lastMergeCommit;

        return $this;
    }

    /**
     * Gets lastMergeSourceCommit
     *
     * @return \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitCommitRef
     */
    public function getLastMergeSourceCommit()
    {
        return $this->container['lastMergeSourceCommit'];
    }

    /**
     * Sets lastMergeSourceCommit
     *
     * @param \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitCommitRef $lastMergeSourceCommit The commit at the head of the source branch at the time of the last pull request merge.
     *
     * @return $this
     */
    public function setLastMergeSourceCommit($lastMergeSourceCommit)
    {
        $this->container['lastMergeSourceCommit'] = $lastMergeSourceCommit;

        return $this;
    }

    /**
     * Gets lastMergeTargetCommit
     *
     * @return \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitCommitRef
     */
    public function getLastMergeTargetCommit()
    {
        return $this->container['lastMergeTargetCommit'];
    }

    /**
     * Sets lastMergeTargetCommit
     *
     * @param \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitCommitRef $lastMergeTargetCommit The commit at the head of the target branch at the time of the last pull request merge.
     *
     * @return $this
     */
    public function setLastMergeTargetCommit($lastMergeTargetCommit)
    {
        $this->container['lastMergeTargetCommit'] = $lastMergeTargetCommit;

        return $this;
    }

    /**
     * Gets mergeFailureMessage
     *
     * @return string
     */
    public function getMergeFailureMessage()
    {
        return $this->container['mergeFailureMessage'];
    }

    /**
     * Sets mergeFailureMessage
     *
     * @param string $mergeFailureMessage If set, pull request merge failed for this reason.
     *
     * @return $this
     */
    public function setMergeFailureMessage($mergeFailureMessage)
    {
        $this->container['mergeFailureMessage'] = $mergeFailureMessage;

        return $this;
    }

    /**
     * Gets mergeFailureType
     *
     * @return string
     */
    public function getMergeFailureType()
    {
        return $this->container['mergeFailureType'];
    }

    /**
     * Sets mergeFailureType
     *
     * @param string $mergeFailureType The type of failure (if any) of the pull request merge.
     *
     * @return $this
     */
    public function setMergeFailureType($mergeFailureType)
    {
        $allowedValues = $this->getMergeFailureTypeAllowableValues();
        if (!is_null($mergeFailureType) && !in_array($mergeFailureType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'mergeFailureType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['mergeFailureType'] = $mergeFailureType;

        return $this;
    }

    /**
     * Gets mergeId
     *
     * @return string
     */
    public function getMergeId()
    {
        return $this->container['mergeId'];
    }

    /**
     * Sets mergeId
     *
     * @param string $mergeId The ID of the job used to run the pull request merge. Used internally.
     *
     * @return $this
     */
    public function setMergeId($mergeId)
    {
        $this->container['mergeId'] = $mergeId;

        return $this;
    }

    /**
     * Gets mergeOptions
     *
     * @return \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitPullRequestMergeOptions
     */
    public function getMergeOptions()
    {
        return $this->container['mergeOptions'];
    }

    /**
     * Sets mergeOptions
     *
     * @param \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitPullRequestMergeOptions $mergeOptions Options used when the pull request merge runs. These are separate from completion options since completion happens only once and a new merge will run every time the source branch of the pull request changes.
     *
     * @return $this
     */
    public function setMergeOptions($mergeOptions)
    {
        $this->container['mergeOptions'] = $mergeOptions;

        return $this;
    }

    /**
     * Gets mergeStatus
     *
     * @return string
     */
    public function getMergeStatus()
    {
        return $this->container['mergeStatus'];
    }

    /**
     * Sets mergeStatus
     *
     * @param string $mergeStatus The current status of the pull request merge.
     *
     * @return $this
     */
    public function setMergeStatus($mergeStatus)
    {
        $allowedValues = $this->getMergeStatusAllowableValues();
        if (!is_null($mergeStatus) && !in_array($mergeStatus, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'mergeStatus', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['mergeStatus'] = $mergeStatus;

        return $this;
    }

    /**
     * Gets pullRequestId
     *
     * @return int
     */
    public function getPullRequestId()
    {
        return $this->container['pullRequestId'];
    }

    /**
     * Sets pullRequestId
     *
     * @param int $pullRequestId The ID of the pull request.
     *
     * @return $this
     */
    public function setPullRequestId($pullRequestId)
    {
        $this->container['pullRequestId'] = $pullRequestId;

        return $this;
    }

    /**
     * Gets remoteUrl
     *
     * @return string
     */
    public function getRemoteUrl()
    {
        return $this->container['remoteUrl'];
    }

    /**
     * Sets remoteUrl
     *
     * @param string $remoteUrl Used internally.
     *
     * @return $this
     */
    public function setRemoteUrl($remoteUrl)
    {
        $this->container['remoteUrl'] = $remoteUrl;

        return $this;
    }

    /**
     * Gets repository
     *
     * @return \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitRepository
     */
    public function getRepository()
    {
        return $this->container['repository'];
    }

    /**
     * Sets repository
     *
     * @param \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\GitRepository $repository The repository containing the target branch of the pull request.
     *
     * @return $this
     */
    public function setRepository($repository)
    {
        $this->container['repository'] = $repository;

        return $this;
    }

    /**
     * Gets reviewers
     *
     * @return \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\IdentityRefWithVote[]
     */
    public function getReviewers()
    {
        return $this->container['reviewers'];
    }

    /**
     * Sets reviewers
     *
     * @param \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\IdentityRefWithVote[] $reviewers A list of reviewers on the pull request along with the state of their votes.
     *
     * @return $this
     */
    public function setReviewers($reviewers)
    {
        $this->container['reviewers'] = $reviewers;

        return $this;
    }

    /**
     * Gets sourceRefName
     *
     * @return string
     */
    public function getSourceRefName()
    {
        return $this->container['sourceRefName'];
    }

    /**
     * Sets sourceRefName
     *
     * @param string $sourceRefName The name of the source branch of the pull request.
     *
     * @return $this
     */
    public function setSourceRefName($sourceRefName)
    {
        $this->container['sourceRefName'] = $sourceRefName;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string $status The status of the pull request.
     *
     * @return $this
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($status) && !in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'status', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets supportsIterations
     *
     * @return bool
     */
    public function getSupportsIterations()
    {
        return $this->container['supportsIterations'];
    }

    /**
     * Sets supportsIterations
     *
     * @param bool $supportsIterations If true, this pull request supports multiple iterations. Iteration support means individual pushes to the source branch of the pull request can be reviewed and comments left in one iteration will be tracked across future iterations.
     *
     * @return $this
     */
    public function setSupportsIterations($supportsIterations)
    {
        $this->container['supportsIterations'] = $supportsIterations;

        return $this;
    }

    /**
     * Gets targetRefName
     *
     * @return string
     */
    public function getTargetRefName()
    {
        return $this->container['targetRefName'];
    }

    /**
     * Sets targetRefName
     *
     * @param string $targetRefName The name of the target branch of the pull request.
     *
     * @return $this
     */
    public function setTargetRefName($targetRefName)
    {
        $this->container['targetRefName'] = $targetRefName;

        return $this;
    }

    /**
     * Gets title
     *
     * @return string
     */
    public function getTitle()
    {
        return $this->container['title'];
    }

    /**
     * Sets title
     *
     * @param string $title The title of the pull request.
     *
     * @return $this
     */
    public function setTitle($title)
    {
        $this->container['title'] = $title;

        return $this;
    }

    /**
     * Gets url
     *
     * @return string
     */
    public function getUrl()
    {
        return $this->container['url'];
    }

    /**
     * Sets url
     *
     * @param string $url Used internally.
     *
     * @return $this
     */
    public function setUrl($url)
    {
        $this->container['url'] = $url;

        return $this;
    }

    /**
     * Gets workItemRefs
     *
     * @return \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\ResourceRef[]
     */
    public function getWorkItemRefs()
    {
        return $this->container['workItemRefs'];
    }

    /**
     * Sets workItemRefs
     *
     * @param \AzureDevOpsClient\Git\AzureDevOpsClient\Git\Model\ResourceRef[] $workItemRefs Any work item references associated with this pull request.
     *
     * @return $this
     */
    public function setWorkItemRefs($workItemRefs)
    {
        $this->container['workItemRefs'] = $workItemRefs;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


