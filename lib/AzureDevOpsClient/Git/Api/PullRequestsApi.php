<?php
/**
 * PullRequestsApi
 * PHP version 5
 *
 * @category Class
 * @package  FrankHouweling\AzureDevOpsClient\Git
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Git
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0-preview
 * Contact: nugetvss@microsoft.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.11-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace FrankHouweling\AzureDevOpsClient\Git\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use FrankHouweling\AzureDevOpsClient\Git\ApiException;
use FrankHouweling\AzureDevOpsClient\Git\Configuration;
use FrankHouweling\AzureDevOpsClient\Git\HeaderSelector;
use FrankHouweling\AzureDevOpsClient\Git\ObjectSerializer;

/**
 * PullRequestsApi Class Doc Comment
 *
 * @category Class
 * @package  FrankHouweling\AzureDevOpsClient\Git
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PullRequestsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation pullRequestsCreate
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest $body The pull request to create. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  bool $supportsIterations If true, subsequent pushes to the pull request will be individually reviewable. Set this to false for large pull requests for performance reasons if this functionality is not needed. (optional)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Git\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest
     */
    public function pullRequestsCreate($organization, $body, $repositoryId, $project, $apiVersion, $supportsIterations = null)
    {
        list($response) = $this->pullRequestsCreateWithHttpInfo($organization, $body, $repositoryId, $project, $apiVersion, $supportsIterations);
        return $response;
    }

    /**
     * Operation pullRequestsCreateWithHttpInfo
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest $body The pull request to create. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  bool $supportsIterations If true, subsequent pushes to the pull request will be individually reviewable. Set this to false for large pull requests for performance reasons if this functionality is not needed. (optional)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Git\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest, HTTP status code, HTTP response headers (array of strings)
     */
    public function pullRequestsCreateWithHttpInfo($organization, $body, $repositoryId, $project, $apiVersion, $supportsIterations = null)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest';
        $request = $this->pullRequestsCreateRequest($organization, $body, $repositoryId, $project, $apiVersion, $supportsIterations);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pullRequestsCreateAsync
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest $body The pull request to create. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  bool $supportsIterations If true, subsequent pushes to the pull request will be individually reviewable. Set this to false for large pull requests for performance reasons if this functionality is not needed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pullRequestsCreateAsync($organization, $body, $repositoryId, $project, $apiVersion, $supportsIterations = null)
    {
        return $this->pullRequestsCreateAsyncWithHttpInfo($organization, $body, $repositoryId, $project, $apiVersion, $supportsIterations)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pullRequestsCreateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest $body The pull request to create. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  bool $supportsIterations If true, subsequent pushes to the pull request will be individually reviewable. Set this to false for large pull requests for performance reasons if this functionality is not needed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pullRequestsCreateAsyncWithHttpInfo($organization, $body, $repositoryId, $project, $apiVersion, $supportsIterations = null)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest';
        $request = $this->pullRequestsCreateRequest($organization, $body, $repositoryId, $project, $apiVersion, $supportsIterations);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pullRequestsCreate'
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest $body The pull request to create. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  bool $supportsIterations If true, subsequent pushes to the pull request will be individually reviewable. Set this to false for large pull requests for performance reasons if this functionality is not needed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pullRequestsCreateRequest($organization, $body, $repositoryId, $project, $apiVersion, $supportsIterations = null)
    {
        // verify the required parameter 'organization' is set
        if ($organization === null || (is_array($organization) && count($organization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization when calling pullRequestsCreate'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling pullRequestsCreate'
            );
        }
        // verify the required parameter 'repositoryId' is set
        if ($repositoryId === null || (is_array($repositoryId) && count($repositoryId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repositoryId when calling pullRequestsCreate'
            );
        }
        // verify the required parameter 'project' is set
        if ($project === null || (is_array($project) && count($project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project when calling pullRequestsCreate'
            );
        }
        // verify the required parameter 'apiVersion' is set
        if ($apiVersion === null || (is_array($apiVersion) && count($apiVersion) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiVersion when calling pullRequestsCreate'
            );
        }

        $resourcePath = '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($supportsIterations !== null) {
            $queryParams['supportsIterations'] = ObjectSerializer::toQueryValue($supportsIterations);
        }
        // query params
        if ($apiVersion !== null) {
            $queryParams['api-version'] = ObjectSerializer::toQueryValue($apiVersion);
        }

        // path params
        if ($organization !== null) {
            $resourcePath = str_replace(
                '{' . 'organization' . '}',
                ObjectSerializer::toPathValue($organization),
                $resourcePath
            );
        }
        // path params
        if ($repositoryId !== null) {
            $resourcePath = str_replace(
                '{' . 'repositoryId' . '}',
                ObjectSerializer::toPathValue($repositoryId),
                $resourcePath
            );
        }
        // path params
        if ($project !== null) {
            $resourcePath = str_replace(
                '{' . 'project' . '}',
                ObjectSerializer::toPathValue($project),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pullRequestsGetPullRequest
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  int $pullRequestId The ID of the pull request to retrieve. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  int $maxCommentLength Not used. (optional)
     * @param  int $skip Not used. (optional)
     * @param  int $top Not used. (optional)
     * @param  bool $includeCommits If true, the pull request will be returned with the associated commits. (optional)
     * @param  bool $includeWorkItemRefs If true, the pull request will be returned with the associated work item references. (optional)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Git\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest
     */
    public function pullRequestsGetPullRequest($organization, $repositoryId, $pullRequestId, $project, $apiVersion, $maxCommentLength = null, $skip = null, $top = null, $includeCommits = null, $includeWorkItemRefs = null)
    {
        list($response) = $this->pullRequestsGetPullRequestWithHttpInfo($organization, $repositoryId, $pullRequestId, $project, $apiVersion, $maxCommentLength, $skip, $top, $includeCommits, $includeWorkItemRefs);
        return $response;
    }

    /**
     * Operation pullRequestsGetPullRequestWithHttpInfo
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  int $pullRequestId The ID of the pull request to retrieve. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  int $maxCommentLength Not used. (optional)
     * @param  int $skip Not used. (optional)
     * @param  int $top Not used. (optional)
     * @param  bool $includeCommits If true, the pull request will be returned with the associated commits. (optional)
     * @param  bool $includeWorkItemRefs If true, the pull request will be returned with the associated work item references. (optional)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Git\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest, HTTP status code, HTTP response headers (array of strings)
     */
    public function pullRequestsGetPullRequestWithHttpInfo($organization, $repositoryId, $pullRequestId, $project, $apiVersion, $maxCommentLength = null, $skip = null, $top = null, $includeCommits = null, $includeWorkItemRefs = null)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest';
        $request = $this->pullRequestsGetPullRequestRequest($organization, $repositoryId, $pullRequestId, $project, $apiVersion, $maxCommentLength, $skip, $top, $includeCommits, $includeWorkItemRefs);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pullRequestsGetPullRequestAsync
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  int $pullRequestId The ID of the pull request to retrieve. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  int $maxCommentLength Not used. (optional)
     * @param  int $skip Not used. (optional)
     * @param  int $top Not used. (optional)
     * @param  bool $includeCommits If true, the pull request will be returned with the associated commits. (optional)
     * @param  bool $includeWorkItemRefs If true, the pull request will be returned with the associated work item references. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pullRequestsGetPullRequestAsync($organization, $repositoryId, $pullRequestId, $project, $apiVersion, $maxCommentLength = null, $skip = null, $top = null, $includeCommits = null, $includeWorkItemRefs = null)
    {
        return $this->pullRequestsGetPullRequestAsyncWithHttpInfo($organization, $repositoryId, $pullRequestId, $project, $apiVersion, $maxCommentLength, $skip, $top, $includeCommits, $includeWorkItemRefs)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pullRequestsGetPullRequestAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  int $pullRequestId The ID of the pull request to retrieve. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  int $maxCommentLength Not used. (optional)
     * @param  int $skip Not used. (optional)
     * @param  int $top Not used. (optional)
     * @param  bool $includeCommits If true, the pull request will be returned with the associated commits. (optional)
     * @param  bool $includeWorkItemRefs If true, the pull request will be returned with the associated work item references. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pullRequestsGetPullRequestAsyncWithHttpInfo($organization, $repositoryId, $pullRequestId, $project, $apiVersion, $maxCommentLength = null, $skip = null, $top = null, $includeCommits = null, $includeWorkItemRefs = null)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest';
        $request = $this->pullRequestsGetPullRequestRequest($organization, $repositoryId, $pullRequestId, $project, $apiVersion, $maxCommentLength, $skip, $top, $includeCommits, $includeWorkItemRefs);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pullRequestsGetPullRequest'
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  int $pullRequestId The ID of the pull request to retrieve. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  int $maxCommentLength Not used. (optional)
     * @param  int $skip Not used. (optional)
     * @param  int $top Not used. (optional)
     * @param  bool $includeCommits If true, the pull request will be returned with the associated commits. (optional)
     * @param  bool $includeWorkItemRefs If true, the pull request will be returned with the associated work item references. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pullRequestsGetPullRequestRequest($organization, $repositoryId, $pullRequestId, $project, $apiVersion, $maxCommentLength = null, $skip = null, $top = null, $includeCommits = null, $includeWorkItemRefs = null)
    {
        // verify the required parameter 'organization' is set
        if ($organization === null || (is_array($organization) && count($organization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization when calling pullRequestsGetPullRequest'
            );
        }
        // verify the required parameter 'repositoryId' is set
        if ($repositoryId === null || (is_array($repositoryId) && count($repositoryId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repositoryId when calling pullRequestsGetPullRequest'
            );
        }
        // verify the required parameter 'pullRequestId' is set
        if ($pullRequestId === null || (is_array($pullRequestId) && count($pullRequestId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pullRequestId when calling pullRequestsGetPullRequest'
            );
        }
        // verify the required parameter 'project' is set
        if ($project === null || (is_array($project) && count($project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project when calling pullRequestsGetPullRequest'
            );
        }
        // verify the required parameter 'apiVersion' is set
        if ($apiVersion === null || (is_array($apiVersion) && count($apiVersion) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiVersion when calling pullRequestsGetPullRequest'
            );
        }

        $resourcePath = '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequests/{pullRequestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($maxCommentLength !== null) {
            $queryParams['maxCommentLength'] = ObjectSerializer::toQueryValue($maxCommentLength);
        }
        // query params
        if ($skip !== null) {
            $queryParams['$skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($top !== null) {
            $queryParams['$top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($includeCommits !== null) {
            $queryParams['includeCommits'] = ObjectSerializer::toQueryValue($includeCommits);
        }
        // query params
        if ($includeWorkItemRefs !== null) {
            $queryParams['includeWorkItemRefs'] = ObjectSerializer::toQueryValue($includeWorkItemRefs);
        }
        // query params
        if ($apiVersion !== null) {
            $queryParams['api-version'] = ObjectSerializer::toQueryValue($apiVersion);
        }

        // path params
        if ($organization !== null) {
            $resourcePath = str_replace(
                '{' . 'organization' . '}',
                ObjectSerializer::toPathValue($organization),
                $resourcePath
            );
        }
        // path params
        if ($repositoryId !== null) {
            $resourcePath = str_replace(
                '{' . 'repositoryId' . '}',
                ObjectSerializer::toPathValue($repositoryId),
                $resourcePath
            );
        }
        // path params
        if ($pullRequestId !== null) {
            $resourcePath = str_replace(
                '{' . 'pullRequestId' . '}',
                ObjectSerializer::toPathValue($pullRequestId),
                $resourcePath
            );
        }
        // path params
        if ($project !== null) {
            $resourcePath = str_replace(
                '{' . 'project' . '}',
                ObjectSerializer::toPathValue($project),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pullRequestsGetPullRequestById
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  int $pullRequestId The ID of the pull request to retrieve. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Git\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest
     */
    public function pullRequestsGetPullRequestById($organization, $pullRequestId, $project, $apiVersion)
    {
        list($response) = $this->pullRequestsGetPullRequestByIdWithHttpInfo($organization, $pullRequestId, $project, $apiVersion);
        return $response;
    }

    /**
     * Operation pullRequestsGetPullRequestByIdWithHttpInfo
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  int $pullRequestId The ID of the pull request to retrieve. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Git\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest, HTTP status code, HTTP response headers (array of strings)
     */
    public function pullRequestsGetPullRequestByIdWithHttpInfo($organization, $pullRequestId, $project, $apiVersion)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest';
        $request = $this->pullRequestsGetPullRequestByIdRequest($organization, $pullRequestId, $project, $apiVersion);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pullRequestsGetPullRequestByIdAsync
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  int $pullRequestId The ID of the pull request to retrieve. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pullRequestsGetPullRequestByIdAsync($organization, $pullRequestId, $project, $apiVersion)
    {
        return $this->pullRequestsGetPullRequestByIdAsyncWithHttpInfo($organization, $pullRequestId, $project, $apiVersion)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pullRequestsGetPullRequestByIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  int $pullRequestId The ID of the pull request to retrieve. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pullRequestsGetPullRequestByIdAsyncWithHttpInfo($organization, $pullRequestId, $project, $apiVersion)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest';
        $request = $this->pullRequestsGetPullRequestByIdRequest($organization, $pullRequestId, $project, $apiVersion);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pullRequestsGetPullRequestById'
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  int $pullRequestId The ID of the pull request to retrieve. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pullRequestsGetPullRequestByIdRequest($organization, $pullRequestId, $project, $apiVersion)
    {
        // verify the required parameter 'organization' is set
        if ($organization === null || (is_array($organization) && count($organization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization when calling pullRequestsGetPullRequestById'
            );
        }
        // verify the required parameter 'pullRequestId' is set
        if ($pullRequestId === null || (is_array($pullRequestId) && count($pullRequestId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pullRequestId when calling pullRequestsGetPullRequestById'
            );
        }
        // verify the required parameter 'project' is set
        if ($project === null || (is_array($project) && count($project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project when calling pullRequestsGetPullRequestById'
            );
        }
        // verify the required parameter 'apiVersion' is set
        if ($apiVersion === null || (is_array($apiVersion) && count($apiVersion) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiVersion when calling pullRequestsGetPullRequestById'
            );
        }

        $resourcePath = '/{organization}/{project}/_apis/git/pullrequests/{pullRequestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($apiVersion !== null) {
            $queryParams['api-version'] = ObjectSerializer::toQueryValue($apiVersion);
        }

        // path params
        if ($organization !== null) {
            $resourcePath = str_replace(
                '{' . 'organization' . '}',
                ObjectSerializer::toPathValue($organization),
                $resourcePath
            );
        }
        // path params
        if ($pullRequestId !== null) {
            $resourcePath = str_replace(
                '{' . 'pullRequestId' . '}',
                ObjectSerializer::toPathValue($pullRequestId),
                $resourcePath
            );
        }
        // path params
        if ($project !== null) {
            $resourcePath = str_replace(
                '{' . 'project' . '}',
                ObjectSerializer::toPathValue($project),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pullRequestsGetPullRequests
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  string $searchCriteriaCreatorId If set, search for pull requests that were created by this identity. (optional)
     * @param  bool $searchCriteriaIncludeLinks Whether to include the _links field on the shallow references (optional)
     * @param  string $searchCriteriaRepositoryId If set, search for pull requests whose target branch is in this repository. (optional)
     * @param  string $searchCriteriaReviewerId If set, search for pull requests that have this identity as a reviewer. (optional)
     * @param  string $searchCriteriaSourceRefName If set, search for pull requests from this branch. (optional)
     * @param  string $searchCriteriaSourceRepositoryId If set, search for pull requests whose source branch is in this repository. (optional)
     * @param  string $searchCriteriaStatus If set, search for pull requests that are in this state. Defaults to Active if unset. (optional)
     * @param  string $searchCriteriaTargetRefName If set, search for pull requests into this branch. (optional)
     * @param  int $maxCommentLength Not used. (optional)
     * @param  int $skip The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100. (optional)
     * @param  int $top The number of pull requests to retrieve. (optional)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Git\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest[]
     */
    public function pullRequestsGetPullRequests($organization, $repositoryId, $project, $apiVersion, $searchCriteriaCreatorId = null, $searchCriteriaIncludeLinks = null, $searchCriteriaRepositoryId = null, $searchCriteriaReviewerId = null, $searchCriteriaSourceRefName = null, $searchCriteriaSourceRepositoryId = null, $searchCriteriaStatus = null, $searchCriteriaTargetRefName = null, $maxCommentLength = null, $skip = null, $top = null)
    {
        list($response) = $this->pullRequestsGetPullRequestsWithHttpInfo($organization, $repositoryId, $project, $apiVersion, $searchCriteriaCreatorId, $searchCriteriaIncludeLinks, $searchCriteriaRepositoryId, $searchCriteriaReviewerId, $searchCriteriaSourceRefName, $searchCriteriaSourceRepositoryId, $searchCriteriaStatus, $searchCriteriaTargetRefName, $maxCommentLength, $skip, $top);
        return $response;
    }

    /**
     * Operation pullRequestsGetPullRequestsWithHttpInfo
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  string $searchCriteriaCreatorId If set, search for pull requests that were created by this identity. (optional)
     * @param  bool $searchCriteriaIncludeLinks Whether to include the _links field on the shallow references (optional)
     * @param  string $searchCriteriaRepositoryId If set, search for pull requests whose target branch is in this repository. (optional)
     * @param  string $searchCriteriaReviewerId If set, search for pull requests that have this identity as a reviewer. (optional)
     * @param  string $searchCriteriaSourceRefName If set, search for pull requests from this branch. (optional)
     * @param  string $searchCriteriaSourceRepositoryId If set, search for pull requests whose source branch is in this repository. (optional)
     * @param  string $searchCriteriaStatus If set, search for pull requests that are in this state. Defaults to Active if unset. (optional)
     * @param  string $searchCriteriaTargetRefName If set, search for pull requests into this branch. (optional)
     * @param  int $maxCommentLength Not used. (optional)
     * @param  int $skip The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100. (optional)
     * @param  int $top The number of pull requests to retrieve. (optional)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Git\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest[], HTTP status code, HTTP response headers (array of strings)
     */
    public function pullRequestsGetPullRequestsWithHttpInfo($organization, $repositoryId, $project, $apiVersion, $searchCriteriaCreatorId = null, $searchCriteriaIncludeLinks = null, $searchCriteriaRepositoryId = null, $searchCriteriaReviewerId = null, $searchCriteriaSourceRefName = null, $searchCriteriaSourceRepositoryId = null, $searchCriteriaStatus = null, $searchCriteriaTargetRefName = null, $maxCommentLength = null, $skip = null, $top = null)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest[]';
        $request = $this->pullRequestsGetPullRequestsRequest($organization, $repositoryId, $project, $apiVersion, $searchCriteriaCreatorId, $searchCriteriaIncludeLinks, $searchCriteriaRepositoryId, $searchCriteriaReviewerId, $searchCriteriaSourceRefName, $searchCriteriaSourceRepositoryId, $searchCriteriaStatus, $searchCriteriaTargetRefName, $maxCommentLength, $skip, $top);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pullRequestsGetPullRequestsAsync
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  string $searchCriteriaCreatorId If set, search for pull requests that were created by this identity. (optional)
     * @param  bool $searchCriteriaIncludeLinks Whether to include the _links field on the shallow references (optional)
     * @param  string $searchCriteriaRepositoryId If set, search for pull requests whose target branch is in this repository. (optional)
     * @param  string $searchCriteriaReviewerId If set, search for pull requests that have this identity as a reviewer. (optional)
     * @param  string $searchCriteriaSourceRefName If set, search for pull requests from this branch. (optional)
     * @param  string $searchCriteriaSourceRepositoryId If set, search for pull requests whose source branch is in this repository. (optional)
     * @param  string $searchCriteriaStatus If set, search for pull requests that are in this state. Defaults to Active if unset. (optional)
     * @param  string $searchCriteriaTargetRefName If set, search for pull requests into this branch. (optional)
     * @param  int $maxCommentLength Not used. (optional)
     * @param  int $skip The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100. (optional)
     * @param  int $top The number of pull requests to retrieve. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pullRequestsGetPullRequestsAsync($organization, $repositoryId, $project, $apiVersion, $searchCriteriaCreatorId = null, $searchCriteriaIncludeLinks = null, $searchCriteriaRepositoryId = null, $searchCriteriaReviewerId = null, $searchCriteriaSourceRefName = null, $searchCriteriaSourceRepositoryId = null, $searchCriteriaStatus = null, $searchCriteriaTargetRefName = null, $maxCommentLength = null, $skip = null, $top = null)
    {
        return $this->pullRequestsGetPullRequestsAsyncWithHttpInfo($organization, $repositoryId, $project, $apiVersion, $searchCriteriaCreatorId, $searchCriteriaIncludeLinks, $searchCriteriaRepositoryId, $searchCriteriaReviewerId, $searchCriteriaSourceRefName, $searchCriteriaSourceRepositoryId, $searchCriteriaStatus, $searchCriteriaTargetRefName, $maxCommentLength, $skip, $top)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pullRequestsGetPullRequestsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  string $searchCriteriaCreatorId If set, search for pull requests that were created by this identity. (optional)
     * @param  bool $searchCriteriaIncludeLinks Whether to include the _links field on the shallow references (optional)
     * @param  string $searchCriteriaRepositoryId If set, search for pull requests whose target branch is in this repository. (optional)
     * @param  string $searchCriteriaReviewerId If set, search for pull requests that have this identity as a reviewer. (optional)
     * @param  string $searchCriteriaSourceRefName If set, search for pull requests from this branch. (optional)
     * @param  string $searchCriteriaSourceRepositoryId If set, search for pull requests whose source branch is in this repository. (optional)
     * @param  string $searchCriteriaStatus If set, search for pull requests that are in this state. Defaults to Active if unset. (optional)
     * @param  string $searchCriteriaTargetRefName If set, search for pull requests into this branch. (optional)
     * @param  int $maxCommentLength Not used. (optional)
     * @param  int $skip The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100. (optional)
     * @param  int $top The number of pull requests to retrieve. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pullRequestsGetPullRequestsAsyncWithHttpInfo($organization, $repositoryId, $project, $apiVersion, $searchCriteriaCreatorId = null, $searchCriteriaIncludeLinks = null, $searchCriteriaRepositoryId = null, $searchCriteriaReviewerId = null, $searchCriteriaSourceRefName = null, $searchCriteriaSourceRepositoryId = null, $searchCriteriaStatus = null, $searchCriteriaTargetRefName = null, $maxCommentLength = null, $skip = null, $top = null)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest[]';
        $request = $this->pullRequestsGetPullRequestsRequest($organization, $repositoryId, $project, $apiVersion, $searchCriteriaCreatorId, $searchCriteriaIncludeLinks, $searchCriteriaRepositoryId, $searchCriteriaReviewerId, $searchCriteriaSourceRefName, $searchCriteriaSourceRepositoryId, $searchCriteriaStatus, $searchCriteriaTargetRefName, $maxCommentLength, $skip, $top);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pullRequestsGetPullRequests'
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  string $searchCriteriaCreatorId If set, search for pull requests that were created by this identity. (optional)
     * @param  bool $searchCriteriaIncludeLinks Whether to include the _links field on the shallow references (optional)
     * @param  string $searchCriteriaRepositoryId If set, search for pull requests whose target branch is in this repository. (optional)
     * @param  string $searchCriteriaReviewerId If set, search for pull requests that have this identity as a reviewer. (optional)
     * @param  string $searchCriteriaSourceRefName If set, search for pull requests from this branch. (optional)
     * @param  string $searchCriteriaSourceRepositoryId If set, search for pull requests whose source branch is in this repository. (optional)
     * @param  string $searchCriteriaStatus If set, search for pull requests that are in this state. Defaults to Active if unset. (optional)
     * @param  string $searchCriteriaTargetRefName If set, search for pull requests into this branch. (optional)
     * @param  int $maxCommentLength Not used. (optional)
     * @param  int $skip The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100. (optional)
     * @param  int $top The number of pull requests to retrieve. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pullRequestsGetPullRequestsRequest($organization, $repositoryId, $project, $apiVersion, $searchCriteriaCreatorId = null, $searchCriteriaIncludeLinks = null, $searchCriteriaRepositoryId = null, $searchCriteriaReviewerId = null, $searchCriteriaSourceRefName = null, $searchCriteriaSourceRepositoryId = null, $searchCriteriaStatus = null, $searchCriteriaTargetRefName = null, $maxCommentLength = null, $skip = null, $top = null)
    {
        // verify the required parameter 'organization' is set
        if ($organization === null || (is_array($organization) && count($organization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization when calling pullRequestsGetPullRequests'
            );
        }
        // verify the required parameter 'repositoryId' is set
        if ($repositoryId === null || (is_array($repositoryId) && count($repositoryId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repositoryId when calling pullRequestsGetPullRequests'
            );
        }
        // verify the required parameter 'project' is set
        if ($project === null || (is_array($project) && count($project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project when calling pullRequestsGetPullRequests'
            );
        }
        // verify the required parameter 'apiVersion' is set
        if ($apiVersion === null || (is_array($apiVersion) && count($apiVersion) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiVersion when calling pullRequestsGetPullRequests'
            );
        }

        $resourcePath = '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($searchCriteriaCreatorId !== null) {
            $queryParams['searchCriteria.creatorId'] = ObjectSerializer::toQueryValue($searchCriteriaCreatorId);
        }
        // query params
        if ($searchCriteriaIncludeLinks !== null) {
            $queryParams['searchCriteria.includeLinks'] = ObjectSerializer::toQueryValue($searchCriteriaIncludeLinks);
        }
        // query params
        if ($searchCriteriaRepositoryId !== null) {
            $queryParams['searchCriteria.repositoryId'] = ObjectSerializer::toQueryValue($searchCriteriaRepositoryId);
        }
        // query params
        if ($searchCriteriaReviewerId !== null) {
            $queryParams['searchCriteria.reviewerId'] = ObjectSerializer::toQueryValue($searchCriteriaReviewerId);
        }
        // query params
        if ($searchCriteriaSourceRefName !== null) {
            $queryParams['searchCriteria.sourceRefName'] = ObjectSerializer::toQueryValue($searchCriteriaSourceRefName);
        }
        // query params
        if ($searchCriteriaSourceRepositoryId !== null) {
            $queryParams['searchCriteria.sourceRepositoryId'] = ObjectSerializer::toQueryValue($searchCriteriaSourceRepositoryId);
        }
        // query params
        if ($searchCriteriaStatus !== null) {
            $queryParams['searchCriteria.status'] = ObjectSerializer::toQueryValue($searchCriteriaStatus);
        }
        // query params
        if ($searchCriteriaTargetRefName !== null) {
            $queryParams['searchCriteria.targetRefName'] = ObjectSerializer::toQueryValue($searchCriteriaTargetRefName);
        }
        // query params
        if ($maxCommentLength !== null) {
            $queryParams['maxCommentLength'] = ObjectSerializer::toQueryValue($maxCommentLength);
        }
        // query params
        if ($skip !== null) {
            $queryParams['$skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($top !== null) {
            $queryParams['$top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($apiVersion !== null) {
            $queryParams['api-version'] = ObjectSerializer::toQueryValue($apiVersion);
        }

        // path params
        if ($organization !== null) {
            $resourcePath = str_replace(
                '{' . 'organization' . '}',
                ObjectSerializer::toPathValue($organization),
                $resourcePath
            );
        }
        // path params
        if ($repositoryId !== null) {
            $resourcePath = str_replace(
                '{' . 'repositoryId' . '}',
                ObjectSerializer::toPathValue($repositoryId),
                $resourcePath
            );
        }
        // path params
        if ($project !== null) {
            $resourcePath = str_replace(
                '{' . 'project' . '}',
                ObjectSerializer::toPathValue($project),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pullRequestsGetPullRequestsByProject
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  string $searchCriteriaCreatorId If set, search for pull requests that were created by this identity. (optional)
     * @param  bool $searchCriteriaIncludeLinks Whether to include the _links field on the shallow references (optional)
     * @param  string $searchCriteriaRepositoryId If set, search for pull requests whose target branch is in this repository. (optional)
     * @param  string $searchCriteriaReviewerId If set, search for pull requests that have this identity as a reviewer. (optional)
     * @param  string $searchCriteriaSourceRefName If set, search for pull requests from this branch. (optional)
     * @param  string $searchCriteriaSourceRepositoryId If set, search for pull requests whose source branch is in this repository. (optional)
     * @param  string $searchCriteriaStatus If set, search for pull requests that are in this state. Defaults to Active if unset. (optional)
     * @param  string $searchCriteriaTargetRefName If set, search for pull requests into this branch. (optional)
     * @param  int $maxCommentLength Not used. (optional)
     * @param  int $skip The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100. (optional)
     * @param  int $top The number of pull requests to retrieve. (optional)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Git\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest[]
     */
    public function pullRequestsGetPullRequestsByProject($organization, $project, $apiVersion, $searchCriteriaCreatorId = null, $searchCriteriaIncludeLinks = null, $searchCriteriaRepositoryId = null, $searchCriteriaReviewerId = null, $searchCriteriaSourceRefName = null, $searchCriteriaSourceRepositoryId = null, $searchCriteriaStatus = null, $searchCriteriaTargetRefName = null, $maxCommentLength = null, $skip = null, $top = null)
    {
        list($response) = $this->pullRequestsGetPullRequestsByProjectWithHttpInfo($organization, $project, $apiVersion, $searchCriteriaCreatorId, $searchCriteriaIncludeLinks, $searchCriteriaRepositoryId, $searchCriteriaReviewerId, $searchCriteriaSourceRefName, $searchCriteriaSourceRepositoryId, $searchCriteriaStatus, $searchCriteriaTargetRefName, $maxCommentLength, $skip, $top);
        return $response;
    }

    /**
     * Operation pullRequestsGetPullRequestsByProjectWithHttpInfo
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  string $searchCriteriaCreatorId If set, search for pull requests that were created by this identity. (optional)
     * @param  bool $searchCriteriaIncludeLinks Whether to include the _links field on the shallow references (optional)
     * @param  string $searchCriteriaRepositoryId If set, search for pull requests whose target branch is in this repository. (optional)
     * @param  string $searchCriteriaReviewerId If set, search for pull requests that have this identity as a reviewer. (optional)
     * @param  string $searchCriteriaSourceRefName If set, search for pull requests from this branch. (optional)
     * @param  string $searchCriteriaSourceRepositoryId If set, search for pull requests whose source branch is in this repository. (optional)
     * @param  string $searchCriteriaStatus If set, search for pull requests that are in this state. Defaults to Active if unset. (optional)
     * @param  string $searchCriteriaTargetRefName If set, search for pull requests into this branch. (optional)
     * @param  int $maxCommentLength Not used. (optional)
     * @param  int $skip The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100. (optional)
     * @param  int $top The number of pull requests to retrieve. (optional)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Git\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest[], HTTP status code, HTTP response headers (array of strings)
     */
    public function pullRequestsGetPullRequestsByProjectWithHttpInfo($organization, $project, $apiVersion, $searchCriteriaCreatorId = null, $searchCriteriaIncludeLinks = null, $searchCriteriaRepositoryId = null, $searchCriteriaReviewerId = null, $searchCriteriaSourceRefName = null, $searchCriteriaSourceRepositoryId = null, $searchCriteriaStatus = null, $searchCriteriaTargetRefName = null, $maxCommentLength = null, $skip = null, $top = null)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest[]';
        $request = $this->pullRequestsGetPullRequestsByProjectRequest($organization, $project, $apiVersion, $searchCriteriaCreatorId, $searchCriteriaIncludeLinks, $searchCriteriaRepositoryId, $searchCriteriaReviewerId, $searchCriteriaSourceRefName, $searchCriteriaSourceRepositoryId, $searchCriteriaStatus, $searchCriteriaTargetRefName, $maxCommentLength, $skip, $top);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pullRequestsGetPullRequestsByProjectAsync
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  string $searchCriteriaCreatorId If set, search for pull requests that were created by this identity. (optional)
     * @param  bool $searchCriteriaIncludeLinks Whether to include the _links field on the shallow references (optional)
     * @param  string $searchCriteriaRepositoryId If set, search for pull requests whose target branch is in this repository. (optional)
     * @param  string $searchCriteriaReviewerId If set, search for pull requests that have this identity as a reviewer. (optional)
     * @param  string $searchCriteriaSourceRefName If set, search for pull requests from this branch. (optional)
     * @param  string $searchCriteriaSourceRepositoryId If set, search for pull requests whose source branch is in this repository. (optional)
     * @param  string $searchCriteriaStatus If set, search for pull requests that are in this state. Defaults to Active if unset. (optional)
     * @param  string $searchCriteriaTargetRefName If set, search for pull requests into this branch. (optional)
     * @param  int $maxCommentLength Not used. (optional)
     * @param  int $skip The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100. (optional)
     * @param  int $top The number of pull requests to retrieve. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pullRequestsGetPullRequestsByProjectAsync($organization, $project, $apiVersion, $searchCriteriaCreatorId = null, $searchCriteriaIncludeLinks = null, $searchCriteriaRepositoryId = null, $searchCriteriaReviewerId = null, $searchCriteriaSourceRefName = null, $searchCriteriaSourceRepositoryId = null, $searchCriteriaStatus = null, $searchCriteriaTargetRefName = null, $maxCommentLength = null, $skip = null, $top = null)
    {
        return $this->pullRequestsGetPullRequestsByProjectAsyncWithHttpInfo($organization, $project, $apiVersion, $searchCriteriaCreatorId, $searchCriteriaIncludeLinks, $searchCriteriaRepositoryId, $searchCriteriaReviewerId, $searchCriteriaSourceRefName, $searchCriteriaSourceRepositoryId, $searchCriteriaStatus, $searchCriteriaTargetRefName, $maxCommentLength, $skip, $top)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pullRequestsGetPullRequestsByProjectAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  string $searchCriteriaCreatorId If set, search for pull requests that were created by this identity. (optional)
     * @param  bool $searchCriteriaIncludeLinks Whether to include the _links field on the shallow references (optional)
     * @param  string $searchCriteriaRepositoryId If set, search for pull requests whose target branch is in this repository. (optional)
     * @param  string $searchCriteriaReviewerId If set, search for pull requests that have this identity as a reviewer. (optional)
     * @param  string $searchCriteriaSourceRefName If set, search for pull requests from this branch. (optional)
     * @param  string $searchCriteriaSourceRepositoryId If set, search for pull requests whose source branch is in this repository. (optional)
     * @param  string $searchCriteriaStatus If set, search for pull requests that are in this state. Defaults to Active if unset. (optional)
     * @param  string $searchCriteriaTargetRefName If set, search for pull requests into this branch. (optional)
     * @param  int $maxCommentLength Not used. (optional)
     * @param  int $skip The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100. (optional)
     * @param  int $top The number of pull requests to retrieve. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pullRequestsGetPullRequestsByProjectAsyncWithHttpInfo($organization, $project, $apiVersion, $searchCriteriaCreatorId = null, $searchCriteriaIncludeLinks = null, $searchCriteriaRepositoryId = null, $searchCriteriaReviewerId = null, $searchCriteriaSourceRefName = null, $searchCriteriaSourceRepositoryId = null, $searchCriteriaStatus = null, $searchCriteriaTargetRefName = null, $maxCommentLength = null, $skip = null, $top = null)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest[]';
        $request = $this->pullRequestsGetPullRequestsByProjectRequest($organization, $project, $apiVersion, $searchCriteriaCreatorId, $searchCriteriaIncludeLinks, $searchCriteriaRepositoryId, $searchCriteriaReviewerId, $searchCriteriaSourceRefName, $searchCriteriaSourceRepositoryId, $searchCriteriaStatus, $searchCriteriaTargetRefName, $maxCommentLength, $skip, $top);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pullRequestsGetPullRequestsByProject'
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     * @param  string $searchCriteriaCreatorId If set, search for pull requests that were created by this identity. (optional)
     * @param  bool $searchCriteriaIncludeLinks Whether to include the _links field on the shallow references (optional)
     * @param  string $searchCriteriaRepositoryId If set, search for pull requests whose target branch is in this repository. (optional)
     * @param  string $searchCriteriaReviewerId If set, search for pull requests that have this identity as a reviewer. (optional)
     * @param  string $searchCriteriaSourceRefName If set, search for pull requests from this branch. (optional)
     * @param  string $searchCriteriaSourceRepositoryId If set, search for pull requests whose source branch is in this repository. (optional)
     * @param  string $searchCriteriaStatus If set, search for pull requests that are in this state. Defaults to Active if unset. (optional)
     * @param  string $searchCriteriaTargetRefName If set, search for pull requests into this branch. (optional)
     * @param  int $maxCommentLength Not used. (optional)
     * @param  int $skip The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100. (optional)
     * @param  int $top The number of pull requests to retrieve. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pullRequestsGetPullRequestsByProjectRequest($organization, $project, $apiVersion, $searchCriteriaCreatorId = null, $searchCriteriaIncludeLinks = null, $searchCriteriaRepositoryId = null, $searchCriteriaReviewerId = null, $searchCriteriaSourceRefName = null, $searchCriteriaSourceRepositoryId = null, $searchCriteriaStatus = null, $searchCriteriaTargetRefName = null, $maxCommentLength = null, $skip = null, $top = null)
    {
        // verify the required parameter 'organization' is set
        if ($organization === null || (is_array($organization) && count($organization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization when calling pullRequestsGetPullRequestsByProject'
            );
        }
        // verify the required parameter 'project' is set
        if ($project === null || (is_array($project) && count($project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project when calling pullRequestsGetPullRequestsByProject'
            );
        }
        // verify the required parameter 'apiVersion' is set
        if ($apiVersion === null || (is_array($apiVersion) && count($apiVersion) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiVersion when calling pullRequestsGetPullRequestsByProject'
            );
        }

        $resourcePath = '/{organization}/{project}/_apis/git/pullrequests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($searchCriteriaCreatorId !== null) {
            $queryParams['searchCriteria.creatorId'] = ObjectSerializer::toQueryValue($searchCriteriaCreatorId);
        }
        // query params
        if ($searchCriteriaIncludeLinks !== null) {
            $queryParams['searchCriteria.includeLinks'] = ObjectSerializer::toQueryValue($searchCriteriaIncludeLinks);
        }
        // query params
        if ($searchCriteriaRepositoryId !== null) {
            $queryParams['searchCriteria.repositoryId'] = ObjectSerializer::toQueryValue($searchCriteriaRepositoryId);
        }
        // query params
        if ($searchCriteriaReviewerId !== null) {
            $queryParams['searchCriteria.reviewerId'] = ObjectSerializer::toQueryValue($searchCriteriaReviewerId);
        }
        // query params
        if ($searchCriteriaSourceRefName !== null) {
            $queryParams['searchCriteria.sourceRefName'] = ObjectSerializer::toQueryValue($searchCriteriaSourceRefName);
        }
        // query params
        if ($searchCriteriaSourceRepositoryId !== null) {
            $queryParams['searchCriteria.sourceRepositoryId'] = ObjectSerializer::toQueryValue($searchCriteriaSourceRepositoryId);
        }
        // query params
        if ($searchCriteriaStatus !== null) {
            $queryParams['searchCriteria.status'] = ObjectSerializer::toQueryValue($searchCriteriaStatus);
        }
        // query params
        if ($searchCriteriaTargetRefName !== null) {
            $queryParams['searchCriteria.targetRefName'] = ObjectSerializer::toQueryValue($searchCriteriaTargetRefName);
        }
        // query params
        if ($maxCommentLength !== null) {
            $queryParams['maxCommentLength'] = ObjectSerializer::toQueryValue($maxCommentLength);
        }
        // query params
        if ($skip !== null) {
            $queryParams['$skip'] = ObjectSerializer::toQueryValue($skip);
        }
        // query params
        if ($top !== null) {
            $queryParams['$top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($apiVersion !== null) {
            $queryParams['api-version'] = ObjectSerializer::toQueryValue($apiVersion);
        }

        // path params
        if ($organization !== null) {
            $resourcePath = str_replace(
                '{' . 'organization' . '}',
                ObjectSerializer::toPathValue($organization),
                $resourcePath
            );
        }
        // path params
        if ($project !== null) {
            $resourcePath = str_replace(
                '{' . 'project' . '}',
                ObjectSerializer::toPathValue($project),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pullRequestsUpdate
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest $body The pull request content that should be updated. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  int $pullRequestId ID of the pull request to update. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Git\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest
     */
    public function pullRequestsUpdate($organization, $body, $repositoryId, $pullRequestId, $project, $apiVersion)
    {
        list($response) = $this->pullRequestsUpdateWithHttpInfo($organization, $body, $repositoryId, $pullRequestId, $project, $apiVersion);
        return $response;
    }

    /**
     * Operation pullRequestsUpdateWithHttpInfo
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest $body The pull request content that should be updated. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  int $pullRequestId ID of the pull request to update. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     *
     * @throws \FrankHouweling\AzureDevOpsClient\Git\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest, HTTP status code, HTTP response headers (array of strings)
     */
    public function pullRequestsUpdateWithHttpInfo($organization, $body, $repositoryId, $pullRequestId, $project, $apiVersion)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest';
        $request = $this->pullRequestsUpdateRequest($organization, $body, $repositoryId, $pullRequestId, $project, $apiVersion);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pullRequestsUpdateAsync
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest $body The pull request content that should be updated. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  int $pullRequestId ID of the pull request to update. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pullRequestsUpdateAsync($organization, $body, $repositoryId, $pullRequestId, $project, $apiVersion)
    {
        return $this->pullRequestsUpdateAsyncWithHttpInfo($organization, $body, $repositoryId, $pullRequestId, $project, $apiVersion)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pullRequestsUpdateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest $body The pull request content that should be updated. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  int $pullRequestId ID of the pull request to update. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pullRequestsUpdateAsyncWithHttpInfo($organization, $body, $repositoryId, $pullRequestId, $project, $apiVersion)
    {
        $returnType = '\FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest';
        $request = $this->pullRequestsUpdateRequest($organization, $body, $repositoryId, $pullRequestId, $project, $apiVersion);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pullRequestsUpdate'
     *
     * @param  string $organization The name of the Azure DevOps organization. (required)
     * @param  \FrankHouweling\AzureDevOpsClient\Git\Model\GitPullRequest $body The pull request content that should be updated. (required)
     * @param  string $repositoryId The repository ID of the pull request&#39;s target branch. (required)
     * @param  int $pullRequestId ID of the pull request to update. (required)
     * @param  string $project Project ID or project name (required)
     * @param  string $apiVersion Version of the API to use.  This should be set to &#39;6.0-preview.1&#39; to use this version of the api. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pullRequestsUpdateRequest($organization, $body, $repositoryId, $pullRequestId, $project, $apiVersion)
    {
        // verify the required parameter 'organization' is set
        if ($organization === null || (is_array($organization) && count($organization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization when calling pullRequestsUpdate'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling pullRequestsUpdate'
            );
        }
        // verify the required parameter 'repositoryId' is set
        if ($repositoryId === null || (is_array($repositoryId) && count($repositoryId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repositoryId when calling pullRequestsUpdate'
            );
        }
        // verify the required parameter 'pullRequestId' is set
        if ($pullRequestId === null || (is_array($pullRequestId) && count($pullRequestId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pullRequestId when calling pullRequestsUpdate'
            );
        }
        // verify the required parameter 'project' is set
        if ($project === null || (is_array($project) && count($project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project when calling pullRequestsUpdate'
            );
        }
        // verify the required parameter 'apiVersion' is set
        if ($apiVersion === null || (is_array($apiVersion) && count($apiVersion) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiVersion when calling pullRequestsUpdate'
            );
        }

        $resourcePath = '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequests/{pullRequestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($apiVersion !== null) {
            $queryParams['api-version'] = ObjectSerializer::toQueryValue($apiVersion);
        }

        // path params
        if ($organization !== null) {
            $resourcePath = str_replace(
                '{' . 'organization' . '}',
                ObjectSerializer::toPathValue($organization),
                $resourcePath
            );
        }
        // path params
        if ($repositoryId !== null) {
            $resourcePath = str_replace(
                '{' . 'repositoryId' . '}',
                ObjectSerializer::toPathValue($repositoryId),
                $resourcePath
            );
        }
        // path params
        if ($pullRequestId !== null) {
            $resourcePath = str_replace(
                '{' . 'pullRequestId' . '}',
                ObjectSerializer::toPathValue($pullRequestId),
                $resourcePath
            );
        }
        // path params
        if ($project !== null) {
            $resourcePath = str_replace(
                '{' . 'project' . '}',
                ObjectSerializer::toPathValue($project),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
